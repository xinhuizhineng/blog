[{"content":"一、系统要求与准备\n系统要求 Windows 11 64位：家庭版/专业版/企业版 必须启用硬件虚拟化（BIOS/UEFI中开启Intel VT-x/AMD-V）\nWSL 2 需要 Windows 10 版本 1903 或更高（Windows 11 已内置）\n至少 4GB RAM（建议8GB以上）\n存储空间：至少 20GB 可用空间\n检查虚拟化是否开启 powershell 打开 PowerShell（管理员） systeminfo\n或使用任务管理器查看 Ctrl+Shift+Esc → 性能 → CPU → \u0026ldquo;虚拟化: 已启用\u0026rdquo; 如果未启用，需要重启进入 BIOS/UEFI 开启：\nIntel CPU：开启 Intel Virtualization Technology (VT-x)\nAMD CPU：开启 AMD-V\n二、安装 Docker Desktop for Windows 方法1：官方安装（推荐） 下载 Docker Desktop\npowershell\n官方下载地址（最新稳定版） https://desktop.docker.com/win/main/amd64/Docker%20Desktop%20Installer.exe 运行安装程序\n双击安装文件\n勾选 \u0026ldquo;Use WSL 2 instead of Hyper-V\u0026rdquo;（推荐）\n安装完成后不要立即启动\n启用 WSL 2 功能\npowershell\n以管理员身份打开 PowerShell dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n重启电脑 shutdown /r /t 0 设置 WSL 2 为默认版本\npowershell wsl \u0026ndash;set-default-version 2 方法2：使用 Winget 安装 powershell\n搜索 Docker Desktop winget search Docker.Desktop\n安装 winget install Docker.DockerDesktop 三、安装后的配置\n首次启动配置 启动 Docker Desktop 接受服务条款\n选择 \u0026ldquo;Use WSL 2 based engine\u0026rdquo;（推荐）\n配置 WSL 集成：\ntext [x] Enable integration with my default WSL distro [x] Ubuntu (或你安装的其他 WSL 发行版) 2. 验证安装 powershell\n打开 PowerShell 或 CMD docker \u0026ndash;version\nDocker version 24.0.6, build ed223bc docker-compose \u0026ndash;version\nDocker Compose version v2.21.0 docker run hello-world\n如果看到欢迎信息，说明安装成功 查看 Docker 信息 docker info 3. WSL 2 后端配置 powershell\n查看 WSL 状态 wsl -l -v\n应该显示： NAME STATE VERSION * Ubuntu Running 2 docker-desktop-data Running 2 docker-desktop Running 2 如果版本不是2，升级： wsl \u0026ndash;set-version Ubuntu 2\n设置默认发行版 wsl \u0026ndash;set-default Ubuntu 四、Docker Desktop 设置优化\n资源分配 打开 Docker Desktop → Settings → Resources： CPU：建议分配 4-8 核（根据你的 CPU 核心数）\nMemory：建议分配 4-8 GB（不要超过总内存的50%）\nSwap：1-2 GB\nDisk image size：至少 50 GB\nDocker Engine 配置 json // Settings → Docker Engine { \u0026ldquo;registry-mirrors\u0026rdquo;: [ \u0026ldquo;https://docker.mirrors.ustc.edu.cn\u0026rdquo;, \u0026ldquo;https://hub-mirror.c.163.com\u0026rdquo; ], \u0026ldquo;insecure-registries\u0026rdquo;: [], \u0026ldquo;debug\u0026rdquo;: false, \u0026ldquo;experimental\u0026rdquo;: false, \u0026ldquo;features\u0026rdquo;: { \u0026ldquo;buildkit\u0026rdquo;: true }, \u0026ldquo;builder\u0026rdquo;: { \u0026ldquo;gc\u0026rdquo;: { \u0026ldquo;enabled\u0026rdquo;: true, \u0026ldquo;defaultKeepStorage\u0026rdquo;: \u0026ldquo;10GB\u0026rdquo; } } } WSL 2 设置 Enable integration with additional WSL 2 distros：选择要集成的发行版 Start Docker Desktop when you log in：根据需要开启\nExpose daemon on tcp://localhost:2375 without TLS：不建议开启\n五、常用命令与操作 基础命令 powershell\n镜像操作 docker images # 查看镜像 docker pull ubuntu:latest # 拉取镜像 docker rmi \u0026lt;image_id\u0026gt; # 删除镜像\n容器操作 docker ps # 查看运行中的容器 docker ps -a # 查看所有容器 docker run -it ubuntu bash # 运行交互式容器 docker start \u0026lt;container_id\u0026gt; # 启动容器 docker stop \u0026lt;container_id\u0026gt; # 停止容器 docker rm \u0026lt;container_id\u0026gt; # 删除容器\n清理 docker system prune -a # 清理所有未使用的资源 Windows 特有命令 powershell\nWSL 与 Docker 交互 wsl \u0026ndash;shutdown # 关闭所有 WSL 发行版 wsl -d docker-desktop # 进入 docker-desktop WSL wsl -d docker-desktop-data # 进入数据卷 WSL\n重启 Docker 服务 net stop com.docker.service net start com.docker.service 六、开发环境配置\n项目结构示例 text my-project/ ├── docker-compose.yml ├── Dockerfile ├── .dockerignore ├── src/ └── data/ 简单 Dockerfile 示例 dockerfile 基础镜像 FROM python:3.11-slim\n设置工作目录 WORKDIR /app\n复制依赖文件 COPY requirements.txt .\n安装依赖 RUN pip install \u0026ndash;no-cache-dir -r requirements.txt\n复制源代码 COPY . .\n暴露端口 EXPOSE 8000\n启动命令 CMD [\u0026ldquo;python\u0026rdquo;, \u0026ldquo;app.py\u0026rdquo;] 3. Docker Compose 示例 yaml version: \u0026lsquo;3.8\u0026rsquo; services: web: build: . ports: - \u0026ldquo;8000:8000\u0026rdquo; volumes: - ./src:/app/src environment: - DEBUG=1 depends_on: - db\ndb: image: postgres:15 environment: POSTGRES_PASSWORD: example volumes: - postgres_data:/var/lib/postgresql/data\nvolumes: postgres_data: 七、常见问题解决\nDocker 启动失败 powershell 1. 检查 WSL 2 是否正常 wsl \u0026ndash;status\n2. 重置 Docker Docker Desktop → Troubleshoot → Reset to factory defaults\n3. 重新安装 WSL 2 内核 下载：https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi 网络问题 powershell 查看 Docker 网络 docker network ls\n创建自定义网络 docker network create my-network\n配置 DNS（在 Docker Desktop Settings → Docker Engine） { \u0026ldquo;dns\u0026rdquo;: [\u0026ldquo;8.8.8.8\u0026rdquo;, \u0026ldquo;114.114.114.114\u0026rdquo;] } 3. 磁盘空间不足 powershell\n清理 Docker 数据 docker system prune \u0026ndash;all \u0026ndash;volumes\n或通过 Docker Desktop Settings → Resources → Advanced → Disk image location\n可以移动到更大的磁盘 权限问题 powershell 以管理员运行 Docker Desktop 或在 PowerShell 中： net localgroup docker-users \u0026ldquo;你的用户名\u0026rdquo; /add 5. 端口被占用 powershell\n查看端口占用 netstat -ano | findstr :端口号\n停止占用进程 taskkill /PID 进程号 /F 八、性能优化建议\n文件系统性能 dockerfile 在 Dockerfile 中使用 .dockerignore .dockerignore 文件内容： .git node_modules *.log *.tmp 2. 卷映射优化 yaml\ndocker-compose.yml version: \u0026lsquo;3.8\u0026rsquo; services: app: volumes: # 使用命名卷（性能更好） - app_data:/data # 特定文件映射（避免整个目录） - ./config:/app/config:ro # 只读\nvolumes: app_data: 3. WSL 2 性能优化 创建 %UserProfile%.wslconfig：\nini [wsl2] memory=8GB # 限制内存使用 processors=4 # 分配 CPU 核心 swap=2GB # 交换空间 localhostForwarding=true 九、GUI 应用支持\n运行 GUI 应用 dockerfile Dockerfile 示例（运行 Firefox） FROM ubuntu:22.04\nRUN apt update \u0026amp;\u0026amp; apt install -y firefox\n允许连接到主机 X11 服务器 ENV DISPLAY=host.docker.internal:0 2. 安装 Windows 的 X 服务器 安装 VcXsrv 或 XMing\n启动 XLaunch，选择 \u0026ldquo;Disable access control\u0026rdquo;\n在 WSL 中设置：\nbash export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk \u0026lsquo;{print $2}\u0026rsquo;):0 十、常用工具扩展\n安装 Docker 扩展 powershell 安装 dive（查看镜像层） docker run \u0026ndash;rm -it wagoodman/dive:latest\n安装 lazydocker（TUI 管理工具） docker run \u0026ndash;rm -it lazyteam/lazydocker 2. VS Code 集成 安装 Docker 和 Dev Containers 扩展\n在项目根目录创建 .devcontainer/devcontainer.json\n按 F1 → Reopen in Container\n十一、备份与迁移\n导出/导入镜像 powershell 导出镜像 docker save -o myimage.tar myimage:tag\n导入镜像 docker load -i myimage.tar\n导出容器 docker export -o mycontainer.tar container_id docker import mycontainer.tar 2. 备份 Docker 数据 powershell\n备份所有镜像 docker save $(docker images -q) -o all_images.tar\n备份卷数据 docker run \u0026ndash;rm -v my_volume:/data -v $(pwd):/backup ubuntu tar czf /backup/backup.tar.gz /data 快速检查清单 虚拟化已启用\nWSL 2 已安装并设为默认\nDocker Desktop 使用 WSL 2 后端\n资源分配合理（内存/CPU/磁盘）\n配置了国内镜像加速器\n防火墙允许 Docker 通信\n","date":"2026-01-20T10:50:00+08:00","permalink":"https://changxiangyu.cn/p/windows-11-%E4%B8%8A%E9%85%8D%E7%BD%AE-docker/","title":"Windows 11 上配置 Docker"},{"content":"什么是并行处理？ 计算机中的并行处理就是同一时刻处理多个任务。使用并行处理能大大提升性能。\n在操作系统中，多线程可以并行处理任务，但需要注意的是：线程是不能单独存在的，它是由进程来启动和管理的。\n核心概念：进程 vs 线程 理解浏览器架构，首先要区分两个核心概念：\n进程 (Process)：一个进程就是一个程序的运行实例。 当你启动一个程序时，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。 线程 (Thread)：线程是依附于进程的。 一个进程中可以包含多个线程，使用多线程并行处理能显著提升运算效率。\n进程和线程关系的 4 个特点：\n牵一发而动全身：进程中的任意一个线程执行出错，都会导致整个进程的崩溃。 数据共享：线程之间共享进程中的数据。 例如：线程 A、B、C 可以分别写入数据，然后由线程 D 读取展示。 内存回收：当一个进程关闭之后，操作系统会完全回收该进程所占用的内存。 进程隔离：进程之间的内容相互隔离。 这是为了保护操作系统，避免进程 A 写入数据到进程 B。正是因为严格隔离，一个进程崩溃（或挂起）不会影响其他进程。如果进程间需要通信，必须使用 IPC (进程间通信) 机制。 一、单进程浏览器时代 单进程浏览器是指浏览器的所有功能模块（网络、插件、JavaScript 运行环境、渲染引擎等）都是运行在同一个进程里。\n这种架构导致了三个致命问题：不稳定、不流畅、不安全。\n不稳定 早期浏览器依赖插件实现功能，但插件很容易崩溃。因为所有模块都在一个进程，一个插件崩溃 = 整个浏览器崩溃。同理，复杂的 JavaScript 代码如果引起渲染引擎崩溃，也会导致浏览器闪退。\n不流畅\n脚本阻塞：无限循环的脚本会霸占整个进程，导致页面无法响应。 内存泄漏：早期的内核在关闭复杂页面后，内存往往不能完全回收。使用时间越长，内存占用越高，浏览器越卡。 不安全 插件通常使用 C/C++ 编写，可以获取操作系统的任意资源。恶意的插件可以窃取账号密码、植入病毒，因为它们没有被限制权限。\n二、多进程浏览器时代（早期） 为了解决单进程的问题，Chrome 推出了多进程架构。\n从图中可以看出，Chrome 的页面运行在单独的渲染进程中，插件也运行在独立的进程中。进程之间通过 IPC 机制通信。\n多进程如何解决旧时代的痛点？\n解决不稳定：由于进程隔离，一个页面或插件崩溃，只会影响当前标签页，不会导致整个浏览器关闭。 解决不流畅：JavaScript 运行在各自的渲染进程中。即使某个页面的脚本死循环，也只会卡死那一个标签页，其他页面依然流畅。同时，关闭标签页时，整个进程被销毁，内存被系统完美回收，解决了内存泄漏问题。 解决不安全：多进程架构引入了安全沙箱 (Sandbox)。 沙箱就像是给进程上了一把锁。沙箱内的程序可以运行，但不能在硬盘写入数据，也不能读取敏感文件。恶意程序无法突破沙箱去获取系统权限。\n三、目前的 Chrome 架构 最新的 Chrome 架构变得更加精细，通常包含：1 个浏览器主进程、1 个 GPU 进程、1 个网络进程、多个渲染进程和多个插件进程。\n主要进程职能： 浏览器进程 (Browser Process) 大管家：负责界面显示、用户交互、子进程管理、存储功能。 渲染进程 (Renderer Process) 核心工匠：负责将 HTML、CSS 和 JavaScript 转换为用户可见的网页。 Blink 排版引擎和 V8 引擎运行在此。 出于安全，运行在沙箱模式下。默认每个 Tab 一个进程。 GPU 进程 图形加速：最初用于 3D CSS，现在广泛用于网页和 UI 的绘制加速。 网络进程 (Network Process) 物资运输：负责页面的网络资源加载。它之前是浏览器进程内的一个模块，现在独立出来，提升了稳定性和性能。 插件进程 (Plugin Process) 外包隔离：负责插件的运行。因插件易崩溃，必须严格隔离。 多进程的代价： 虽然提升了体验，但也带来了新问题：\n资源占用高：每个进程都有独立的副本（如 V8 引擎环境），消耗更多内存。 架构复杂：模块间耦合度高，扩展性变差，难以适应新需求。 四、未来：面向服务的架构 (SOA) 为了解决架构臃肿问题，2016 年起，Chrome 团队开始向 “面向服务的架构” (Services Oriented Architecture) 转型。\n核心思想是将原来的各种模块重构为独立的服务 (Service)。\n每个服务可以在独立的进程中运行。 访问服务必须通过定义好的接口（IPC）。 目标：构建一个更内聚、松耦合、易于维护的系统。 Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为类似操作系统底层的“基础服务”。\n总结 单进程时代：不稳定、卡顿、不安全，但架构简单。 多进程时代：Chrome 创造性地引入多进程，利用进程隔离和沙箱解决了旧时代的难题，但也导致了内存占用高和架构复杂。 SOA 时代：为了适应移动设备、VR 等新场景，Chrome 正将架构重构为面向服务的形式，以实现更优的性能和扩展性。 Chrome 的进化速度极快，越来越多的业务（如视频编辑、3D 游戏）正在迁移到浏览器端。作为开发者，理解浏览器的底层架构，能帮助我们更好地把握这波技术红利。\n","date":"2025-10-28T10:05:18+08:00","permalink":"https://changxiangyu.cn/p/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-chrome-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%BB%8E%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%88%B0-soa/","title":"深入解析 Chrome 浏览器架构演进：从单进程到 SOA"},{"content":"一个数据包的“旅程” 1. IP：把数据包送达目的主机 计算机在网络中的地址称为 IP 地址。访问任何网站，本质上都是你的计算机向另一台计算机请求信息的过程。\n简化的 IP 网络三层传输模型： 2. UDP：把数据包送达应用程序 IP 协议负责将数据包发送给指定的计算机，但这还不够，因为计算机上运行着各种不同的程序。\n定义：“用户数据包协议（User Datagram Protocol）”，简称 UDP。 作用：UDP 中最重要的信息是端口号。IP 通过 IP 地址把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序。 特点：UDP 不保证数据的可靠性，但传输速度非常快，适用于对实时性要求高但对丢包不敏感的应用（如视频会议、在线游戏）。 简化的 UDP 网络四层传输模型： 3. TCP：把数据完整地送达应用程序 对于要求数据传输**可靠性（Reliability）**的应用，如果直接使用 UDP 传输会面临两个主要问题：\n丢包：数据包在传输过程中容易丢失。 乱序：大文件会被拆分成多个小数据包传输，这些数据包可能经过不同的路由、在不同时间到达。UDP 无法将这些乱序包还原为原始文件。 TCP（Transmission Control Protocol，传输控制协议） 是一种面向连接的、可靠的、基于字节流的传输层通信协议。相对于 UDP，TCP 具备以下核心特点：\n重传机制：针对数据包丢失的情况，TCP 提供重传功能。 排序机制：TCP 引入了数据包排序，保证乱序到达的数据包能被重新组合成完整的文件。 简化的 TCP 网络四层传输模型： TCP 连接的生命周期 一个完整的 TCP 连接生命周期包含三个阶段：“建立连接”、“传输数据”和“断开连接”。\n建立连接阶段\n该阶段通过“三次握手”来建立客户端和服务器之间的连接。 TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前，先做好两端之间的准备工作。 三次握手：指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。 传输数据阶段\n在该阶段，接收端需要对每个数据包进行确认操作。即接收端收到数据包后，需发送确认数据包给发送端。 重发机制：若发送端在规定时间内未收到确认消息，则判断数据包丢失，触发重发。 排序重组：大文件被拆分的小数据包到达接收端后，接收端会根据 TCP 头中的序号进行排序，从而保证组成完整的数据。 断开连接阶段\n数据传输完毕后，需要终止连接。 此阶段涉及“四次挥手”，以确保双方都能安全断开连接，释放资源。 总结 数据包传输：互联网中的数据通过数据包传输，传输过程面临丢失或出错的风险。 IP 协议：负责将数据包准确送达目的主机。 UDP 协议：负责通过端口号将数据包分发给具体的应用程序，速度快但不可靠。 TCP 协议：保证数据的完整性和可靠性。其连接生命周期分为三个阶段： 建立连接（三次握手） 传输数据（确认、重传、排序） 断开连接（四次挥手） ","date":"2025-06-18T14:05:18+08:00","permalink":"https://changxiangyu.cn/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-tcp-%E5%8D%8F%E8%AE%AE/","title":"深入理解 TCP 协议"},{"content":"浏览器端发起 HTTP 请求流程 1. 构建请求 (Build Request) 首先，浏览器构建请求行信息，构建好后，浏览器准备发起网络请求。 GET /index.html HTTP1.1\n2. 查找缓存 (Check Cache) 在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。 当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有：\n缓解服务器端压力，提升性能（获取资源的耗时更短了）； 对于网站来说，缓存是实现快速资源加载的重要组成部分。 3. 准备 IP 地址和端口 (DNS Resolution) 因为浏览器使用 HTTP 协议作为应用层协议，用来封装请求的文本信息；并使用 TCP/IP 作传输层协议将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 HTTP 的内容是通过 TCP 的传输数据阶段来实现的 第一步浏览器会请求 DNS 返回域名对应的 IP。当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。\n4. 等待 TCP 队列 (Queueing) Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。 背景：这是 HTTP/1.1 协议下的浏览器限制，导致了“队头阻塞”问题。 优化：现在的 HTTP/2 协议支持多路复用 (Multiplexing)，可以在一个 TCP 连接中并发处理无数个请求，从而突破了这 6 个连接的限制，极大提升了加载效率。\n5. 建立 TCP 连接 (TCP Handshake) 排队等待结束之后，终于可以快乐地和服务器握手了，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。\n6. 发送 HTTP 请求 (Send Request) 一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。 HTTP 请求数据格式 服务器端处理 HTTP 请求流程 1. 返回请求 (Server Response) 服务器响应的数据格式 首先服务器会返回响应行，包括协议版本和状态码。 那么一些无法处理或者处理出错的信息，服务器会通过请求行的状态码来告诉浏览器它的处理结果 服务器也会随同响应向浏览器发送响应头。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容。 2. 断开连接 (Connection Handling) 通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：Connection:Keep-Alive ，那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度\n3. 重定向 (Redirect) 当你在浏览器中打开 后，你会发现最终打开的页面地址是 。这两个 URL 之所以不一样，是因为涉及到了一个重定向操作。 在控制台输入如下命令：curl -I geekbang.org注意这里输入的参数是-I，和-i不一样，-I表示只需要获取响应头和响应行数据，而不需要获取响应体的数据，最终返回的数据如下图所示： 响应行返回的状态码是 301，状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。 301 (Moved Permanently)：永久重定向。浏览器会缓存这个重定向，下次直接去新地址，不再请求旧地址（SEO 友好）。 302 (Found)：临时重定向。浏览器不会缓存重定向关系，每次还是先去旧地址，再被踢到新地址。 1. 为什么很多站点第二次打开速度会很快？ 主要原因是第一次加载页面过程中，缓存了一些耗时的数据 DNS 缓存和页面资源缓存这两块数据是会被浏览器缓存的。DNS 缓存主要就是在浏览器本地把对应的 IP 和域名关联起来 强缓存 (本地直接用) 标志：Cache-Control: Max-age=2000 (HTTP/1.1) 或 Expires (HTTP/1.0)。 行为：浏览器直接判断资源未过期，不向服务器发送任何请求，直接从磁盘/内存读取。状态码通常显示为 200 (from memory cache / disk cache)。 协商缓存 (问问服务器能不能用) 标志：If-None-Match (对应 ETag) 或 If-Modified-Since (对应 Last-Modified)。 行为：强缓存失效后，浏览器发送请求询问服务器。 如果服务器说“没变”：返回 304 Not Modified，浏览器继续用旧的。 如果服务器说“变了”：返回 200 OK 和新内容。 缓存查找流程示意图 从上图的第一次请求可以看出，当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比如上图设置的缓存过期时间是 2000 秒。 Cache-Control:Max-age=2000\n这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。但如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上： If-None-Match:\u0026quot;4f80f-13c-3a1xb12a\u0026quot;\n服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。\n如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。” 如果资源有更新，服务器就直接返回最新资源给浏览器。 2. 登录状态是如何保持的？ 用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用 POST 方法提交用户登录信息给服务器。 服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，如下所示，然后把响应头发送给浏览器。 Set-Cookie: UID=3431uad; 浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把UID=3431uad保持到本地。 当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。 Cookie: UID=3431uad; 服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含UID=3431uad的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。 浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。 Cookie 流程图 总结 HTTP 请求流程示意图 ","date":"2025-04-08T13:06:18+08:00","permalink":"https://changxiangyu.cn/p/http%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/","title":"HTTP请求流程"},{"content":"从输入 URL 到页面展示，这中间发生了什么？ 从输入 URL 到页面展示完整流程示意图： 浏览器进程：主要负责用户交互、子进程管理和文件储存等功能。 网络进程：面向渲染进程和浏览器进程等提供网络下载功能。 渲染进程：主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。 因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。 这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全。 简要流程：\n首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。 然后，在网络进程中发起真正的 URL 请求。 接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。 浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程。 渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道。 最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。 浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。 用户发出 URL 请求到页面开始解析的这个过程，就叫做 导航。\n详细阶段解析 1. 用户输入 当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是 搜索内容，还是 请求的 URL。\n如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。 如果判断输入内容符合 URL 规则，比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL，如 https://time.geekbang.org。 当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面。不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件的机会。\nbeforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。\n当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为极客时间的页面。因为需要等待提交文档阶段，页面内容才会被替换。\n2. URL 请求过程 浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。\n首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。 这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。 接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。 服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。 在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。\n（1）重定向 在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。\n使用 curl -I + URL 的命令可以接收服务器返回的响应头的信息。\nHTTP 向极客时间服务器请求时，服务器会返回一个包含有 301 或者 302 状态码响应头，并把响应头的 Location 字段中填上 HTTPS 的地址，这就是告诉了浏览器要重新导航到新的地址上。\n（2）响应数据类型处理 Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型。\n案例 A：HTML 类型 执行命令：curl -I https://time.geekbang.org/\n响应头中的 Content-type 字段的值是 text/html，这就是告诉浏览器，服务器返回的数据是 HTML 格式。\n案例 B：下载类型 执行命令：curl -I https://res001.geekbang.org/.../geektime.apk\n从返回的响应头信息来看，其 Content-Type 的值是 application/octet-stream，显示数据是 字节流类型 的，通常情况下，浏览器会按照 下载类型 来处理该请求。\n如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。\n3. 准备渲染进程 那什么情况下多个页面会同时运行在一个渲染进程中呢？\n同一站点（same-site）：定义为 根域名（例如，geekbang.org）加上 协议（例如，https:// 或者 http://），还包含了该根域名下的所有子域名和不同的端口。\nChrome 的默认策略是，每个标签对应一个渲染进程。但 如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。\n总结来说，打开一个新页面采用的 渲染进程策略 就是：\n通常情况下，打开新的页面都会使用单独的渲染进程； 如果从 A 页面打开 B 页面，且 A 和 B 都属于 同一站点 的话，那么 B 页面复用 A 页面的渲染进程； 如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。 渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程。\n4. 提交文档 所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程。\n首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息； 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”； 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程； 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。 到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。\n5. 渲染阶段 一旦文档被提交，渲染进程便开始页面解析和子资源加载了。一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。\n总结 服务器可以根据响应头来控制浏览器的行为，如跳转、网络数据类型判断。\nChrome 默认采用每个标签对应一个渲染进程，但是如果两个页面属于同一站点，那这两个标签会使用同一个渲染进程。\n浏览器的导航过程涵盖了从用户发起请求到提交文档给渲染进程的中间所有阶段。\n浏览器进程（Browser Process）主导： 处理输入：区分是搜索关键字还是 URL。 生命周期管理：触发 beforeunload 事件（允许页面清理或取消导航）。 状态更新：加载动画开始，但页面内容需等待“提交文档”后才替换。 网络进程（Network Process）执行： 资源查找：先查本地缓存，无缓存则发起网络请求。 建立连接：DNS 解析 -\u0026gt; 建立 TCP 连接 -\u0026gt; 构建请求头/Cookie。 处理响应： 重定向：若遇 301/302，读取 Location 重新发起请求。 类型判断：通过 Content-Type 判断是下载（application/octet-stream）还是 HTML 导航（text/html）。 准备渲染进程（Render Process）： 默认策略：通常每个标签页一个进程。 同一站点（Same-site）策略：如果新页面与旧页面属于同一站点（根域名+协议相同），则复用父页面的渲染进程（process-per-site-instance）。 提交文档（Commit Navigation）： 这是导航流程的终点。浏览器进程通知渲染进程，渲染进程与网络进程建立数据管道接收 HTML。 一旦确认提交，旧文档被移除，界面 UI（地址栏、后退按钮等）正式更新。 ","date":"2025-01-30T13:05:18+08:00","permalink":"https://changxiangyu.cn/p/%E5%AF%BC%E8%88%AA%E6%B5%81%E7%A8%8B/","title":"导航流程"},{"content":"基本原理 通过监听鼠标的按下（mousedown），弹起（mouseup），移动（mousemove）三个事件来计算移动的距离，从而调整模态框的新位置。\n鼠标按下（mousedown）： 记录鼠标按下时的位置和弹窗当前的位置，并设置弹窗左侧和顶部边距为当前位置； 将 canMove 标志设置为 true，表示模态框可以移动。 鼠标弹起（mouseup）： 将 canMove 标志设置为 false，表示停止移动模态框。 鼠标移动（mousemove）： 如果 canMove 为 true，则计算鼠标移动距离。 根据鼠标的移动距离调整模态框的新位置，使用渲染器设置模态框的新左侧和顶部偏移值，从而实现拖拽效果。 通过nz-modal模板生成的弹窗 实现步骤：\n1.通过指令来绑定拖拽方法( drag-modal.directive.ts )： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import { Directive, Input } from \u0026#39;@angular/core\u0026#39;; import { NzModalRef } from \u0026#39;ng-zorro-antd/modal\u0026#39;; import { ModalDragService } from \u0026#39;./drag-modal.service.ts\u0026#39;; @Directive({ selector: \u0026#39;[dragModal]\u0026#39; }) export class DragModalDirective { @Input() dragModal: NzModalRef; constructor(private modalDragService: ModalDragService) { } ngAfterViewInit() { setTimeout(() =\u0026gt; { this.modalDragService.enableModalDrag(this.dragModal); }, 1000); } } 2.注册模块 (modal-drag.module.ts) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { NgModule } from \u0026#39;@angular/core\u0026#39;; import { CommonModule } from \u0026#39;@angular/common\u0026#39;; import { DragModalDirective } from \u0026#34;./drag-modal.directive\u0026#34;; import { ModalDragService } from \u0026#39;./drag-modal.service.ts\u0026#39;; @NgModule({ providers: [ModalDragService], declarations: [DragModalDirective], imports: [ CommonModule, ], exports: [DragModalDirective] }) export class ModalDragModule { } 使用方法：\n将 ModalDragModule 导入到需要使用弹窗拖拽的功能模块中。 在 \u0026lt;nz-modal\u0026gt; 标签中增加一个模板引用变量（例如 #modal）。 将该变量传递给 dragModal 指令。 通过NzModalService服务创建的弹窗 实现步骤： 利用服务把事件绑定在modal的header上，通过控制mousedown,mouseup,mousemove，来实现拖拽\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 import { Injectable, RendererFactory2 } from \u0026#39;@angular/core\u0026#39;; @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class ModalDragService { constructor(private rendererFactory2: RendererFactory2,) { } // 激活弹窗拖拽 enableModalDrag(refModal) { refModal.afterOpen.subscribe(() =\u0026gt; { const render = this.rendererFactory2.createRenderer(null, null); // 整个悬浮层的dom const modalBackground = refModal.getElement(); // 弹窗的dom const modalElement = refModal.getElement().querySelector(\u0026#39;.ant-modal-content\u0026#39;); // 弹窗header的dom const modalTitleElement = this.createModalTitleElement(render, modalElement); // 绑定拖拽事件 this.dragListen(render, modalTitleElement, modalElement, modalBackground); }) } // 自定义弹窗header拖拽区域的大小 createModalTitleElement(render, modalElement) { let element = document.createElement(\u0026#39;div\u0026#39;) as any; render.setStyle(element, \u0026#39;width\u0026#39;, \u0026#39;100%\u0026#39;); render.setStyle(element, \u0026#39;height\u0026#39;, \u0026#39;54px\u0026#39;); render.setStyle(element, \u0026#39;position\u0026#39;, \u0026#39;absolute\u0026#39;); render.setStyle(element, \u0026#39;top\u0026#39;, \u0026#39;0\u0026#39;); render.setStyle(element, \u0026#39;left\u0026#39;, \u0026#39;0\u0026#39;); render.setStyle(element, \u0026#39;cursor\u0026#39;, \u0026#39;move\u0026#39;); render.setStyle(element, \u0026#39;-moz-user-select\u0026#39;, \u0026#39;none\u0026#39;); render.setStyle(element, \u0026#39;-webkit-user-select\u0026#39;, \u0026#39;none\u0026#39;); render.setStyle(element, \u0026#39;-ms-user-select\u0026#39;, \u0026#39;none\u0026#39;); render.setStyle(element, \u0026#39;-khtml-user-select\u0026#39;, \u0026#39;none\u0026#39;); render.setStyle(element, \u0026#39;user-select\u0026#39;, \u0026#39;none\u0026#39;); render.appendChild(modalElement, element); return element; } // 监听鼠标的mousedown，mouseup，mousemove事件 dragListen(render, modalTitleElement, modalElement, modalBackground) { render.listen(modalTitleElement, \u0026#39;mousedown\u0026#39;, function (event) { // 记录了鼠标按下时的位置（mouseDownX 和 mouseDownY）。 // 获取了模态框当前的位置（modalX 和 modalY）。 // 设置模态框的左侧和顶部边距为当前位置。 // 将 canMove 标志设置为 true，表示模态框可以移动。 this.mouseDownX = event.clientX; this.mouseDownY = event.clientY; this.modalX = modalElement.offsetLeft; this.modalY = modalElement.offsetTop; render.setStyle(modalElement, \u0026#39;left\u0026#39;, `${this.modalX}px`); render.setStyle(modalElement, \u0026#39;top\u0026#39;, `${this.modalY}px`); this.canMove = true; }.bind(this)); render.listen(modalTitleElement, \u0026#39;mouseup\u0026#39;, function (event) { // 将 canMove 标志设置为 false，表示停止移动模态框 this.canMove = false; }.bind(this)); render.listen(modalBackground, \u0026#39;mousemove\u0026#39;, function (event) { // 如果 canMove 为 true，则计算鼠标移动距离。 // 根据鼠标的移动距离调整模态框的新位置。 // 使用渲染器设置模态框的新左侧和顶部偏移值，从而实现拖拽效果。 if (this.canMove) { let moveX = event.clientX - this.mouseDownX; let moveY = event.clientY - this.mouseDownY; let newModalX = this.modalX + moveX; let newModalY = this.modalY + moveY; render.setStyle(modalElement, \u0026#39;left\u0026#39;, `${newModalX}px`); render.setStyle(modalElement, \u0026#39;top\u0026#39;, `${newModalY}px`); } }.bind(this)); } } 在初始化modal时，使用modalDragService的enableModalDrag方法激活拖拽功能；\n使用方法：\n","date":"2024-01-22T10:05:18+08:00","permalink":"https://changxiangyu.cn/p/angular--ng-zorro-%E6%A8%A1%E6%80%81%E6%A1%86%E6%8B%96%E6%8B%BD%E5%8A%9F%E8%83%BD/","title":"Angular + Ng-Zorro 模态框拖拽功能"},{"content":"NVM 安装与配置完全指南 NVM (Node Version Manager) 是管理 Node.js 版本的利器，允许您在同一台设备上切换不同版本的 Node.js，以适应不同的项目需求。\n第一步：清理旧环境（重要） 注意： 在安装 NVM 之前，必须彻底卸载电脑上现有的 Node.js 版本并删除残留文件，否则极易产生路径冲突。\nWindows 用户 打开“控制面板” -\u0026gt; “卸载程序”，卸载 Node.js。 手动检查并删除安装目录（通常为 C:\\Program Files\\nodejs）。 检查用户目录下（C:\\Users\\用户名）是否存在 node_modules、.npm 或 .npmrc 文件/文件夹，建议一并删除。 macOS 用户 如果之前通过 pkg 安装，建议手动删除 /usr/local/bin/node、/usr/local/lib/node_modules 等相关文件。 如果是通过 Homebrew 安装，运行：brew uninstall node。 第二步：安装 NVM 方案 A：Windows 系统 (nvm-windows) 1. 下载与安装 下载地址：GitHub - nvm-windows releases 操作：推荐下载 nvm-setup.exe。双击运行，按照提示点击“下一步”即可。 提示：安装路径建议保持默认，或者确保路径中不包含空格和中文字符。 2. 环境变量配置 (关键步骤) 虽然安装程序通常会自动配置，但为了确保稳定性，建议手动检查以下配置：\n打开设置：右键“此电脑” -\u0026gt; “属性” -\u0026gt; “高级系统设置” -\u0026gt; “环境变量”。 检查/新建用户变量： 变量名 变量值示例 说明 NVM_HOME C:\\Users\\YourUser\\AppData\\Roaming\\nvm NVM 的安装目录 NVM_SYMLINK C:\\Program Files\\nodejs Node.js 的快捷方式映射目录 编辑 Path 变量： 在“用户变量”或“系统变量”中找到 Path，点击“编辑”，确保列表中包含以下两项引用： 1 2 %NVM_HOME% %NVM_SYMLINK% 生效：保存设置后，重启 CMD 或 PowerShell 窗口。 3. 配置 NVM 国内镜像 为了解决下载慢的问题，请在管理员权限的终端中运行：\n1 2 nvm node_mirror https://npmmirror.com/mirrors/node/ nvm npm_mirror https://npmmirror.com/mirrors/npm/ 进阶配置：自定义 NPM 全局路径 (Windows 推荐) 此步骤可选，但强烈建议配置，以便统一管理全局包（如 vue-cli, yarn）。\n新建文件夹 在您的 NVM 或任意目录下手动创建两个文件夹： D:\\nodejs\\node_global (存放全局包) D:\\nodejs\\node_cache (存放缓存) 2. 修改 NPM 配置 打开终端执行：\n1 2 3 4 5 bash # 设置全局模块的安装路径 npm config set prefix \u0026#34;D:\\nodejs\\node_global\u0026#34; # 设置缓存路径 npm config set cache \u0026#34;D:\\nodejs\\node_cache\u0026#34; 执行完毕后，您可以运行 npm config list 检查是否生效。\n配置全局路径环境变量 (Environment Variables) 如果不配置此项，安装的全局命令（如 vue）将无法识别。\n操作路径：右键“此电脑” -\u0026gt; 属性 -\u0026gt; 高级系统设置 -\u0026gt; 环境变量。\n配置 Path 变量 (系统变量/用户变量)： 找到 Path 变量 -\u0026gt; 编辑 -\u0026gt; 新建。 添加路径：D:\\nodejs\\node_global 配置 NODE_PATH (系统变量)，在“系统变量”区域，点击“新建”： 新建变量名：NODE_PATH 变量值：D:\\nodejs\\node_global\\node_modules 注意：必须多加一层 node_modules，否则 require 无法找到模块。 验证： 重启终端后，运行 npm install express -g，检查是否安装到了新目录。 特别提示（如果您正在使用 NVM） 如果您是配合 NVM 使用此配置，这意味着所有 Node 版本都会共用这个 node_global。\n优点：切换 Node 版本后，不需要重新安装全局包（如 yarn, cnpm）。 缺点：如果某个全局包依赖特定的 Node 版本（例如旧版 Sass），切换 Node 版本后可能会导致该工具报错。 方案 B：macOS / Linux 系统 (nvm) 安装脚本 打开终端，运行官方安装脚本： 1 2 bash curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash (如果网络连接失败，请尝试搜索“nvm gitee”寻找国内搬运脚本)\n配置环境变量 安装脚本通常会自动写入配置文件。如果没有生效（输入 nvm 提示 command not found），请手动配置：\n编辑配置文件：\n1 2 macOS (Zsh): vim ~/.zshrc Linux (Bash): vim ~/.bashrc 添加以下内容： 1 2 3 4 5 6 7 bash export NVM_DIR=\u0026#34;$HOME/.nvm\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # 加载 nvm [ -s \u0026#34;$NVM_DIR/bash_completion\u0026#34; ] \u0026amp;\u0026amp; \\. \u0026#34;$NVM_DIR/bash_completion\u0026#34; # 加载自动补全 #在此处也可以直接配置国内镜像变量 export NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node/ 使配置生效： 1 2 bash source ~/.zshrc # 或 source ~/.bashrc 第三步：使用 NVM 安装 Node.js 配置好 NVM 后，即可灵活管理 Node 版本。\n查看可安装版本： 1 2 3 bash nvm list available # Windows nvm ls-remote # Mac/Linux 安装指定版本（推荐安装 LTS 长期支持版）： 1 2 3 bash nvm install 18.17.0 # 安装具体的版本号 nvm install lts # 自动安装最新的 LTS 版本 切换/使用版本： 1 2 3 bash nvm use 18.17.0 (Windows 用户如果遇到 \u0026#34;exit status 1\u0026#34; 乱码报错，请右键选择*“以管理员身份运行”*终端) 查看当前已安装版本： 1 2 bash nvm list 第四步：配置 NPM 镜像（加速依赖包下载） 安装完 Node.js 后，npm 命令自动可用。建议配置淘宝镜像（npmmirror）以加速 npm install。\n设置镜像源： 1 2 bash npm config set registry https://registry.npmmirror.com 验证是否成功： 1 2 3 bash npm config get registry # 预期输出: https://registry.npmmirror.com/ 常用命令速查表 命令 说明 nvm install \u0026lt;version\u0026gt; 安装指定版本 (如 nvm install 20.10.0) nvm use \u0026lt;version\u0026gt; 切换到指定版本 nvm list 列出本地已安装的所有版本 nvm uninstall \u0026lt;version\u0026gt; 卸载指定版本 nvm alias default \u0026lt;version\u0026gt; (Mac/Linux) 设置默认版本，新开终端自动生效 node -v 查看当前正在使用的 Node 版本 npm -v 查看当前正在使用的 NPM 版本 💡 常见问题提示 权限问题：Windows 用户在执行 nvm use 切换版本时，必须使用管理员身份运行 CMD 或 PowerShell，否则无法创建软链接。 路径空格：确保 NVM 安装路径不包含空格（如 Program Files 有时会引起兼容性问题，建议安装在 C:\\nvm 或类似简单路径）。\n","date":"2024-01-18T11:02:00+08:00","permalink":"https://changxiangyu.cn/p/nvm-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/","title":"NVM 安装与配置完全指南"},{"content":"1. 全局与局部配置 (git config) git config 命令的作用是配置 Git 的相关信息。\n用户名与邮箱配置 全局配置 (适用于所有项目): Mac 下可通过终端输入 cat ~/.gitconfig 查看。\ngit config --global user.name \u0026quot;name\u0026quot;\ngit config --global user.email \u0026quot;email\u0026quot;\n单个仓库配置 (仅适用于当前项目): 进入项目根目录，输入 cat .git/config 查看。\ngit config user.name \u0026quot;name\u0026quot;\ngit config user.email \u0026quot;email\u0026quot;\n查看配置 查看所有配置信息\ngit config --list\n查看当前配置的用户名\ngit config user.name\n查看当前配置的用户邮箱\ngit config user.email 定义命令别名 (Alias) 为了提高效率，可以给常用命令设置简写：\ngit config --global alias.st status # git st = git status\ngit config --global alias.co checkout # git co = git checkout\ngit config --global alias.ci commit # git ci = git commit\ngit config --global alias.br branch # git br = git branch\n2. 初始化与远程连接 (git init) git init 用于在当前目录初始化仓库，生成 .git 目录。\n初始化仓库\ngit init\n连接远程项目 (origin 后接仓库地址)\ngit remote add origin \u0026lt;git项目链接\u0026gt;\n从远程项目拉取文件 (首次拉取建议加 \u0026ndash;rebase)\ngit pull --rebase origin master\n推送本地仓库到 Github (首次推送需 -u 绑定上游分支)\ngit push -u origin master\n3. 查看文件状态 (git status) 红色表示工作区修改未提交到暂存区，绿色表示已提交到暂存区。\n标准显示\ngit status\n极简方式显示\ngit status -s\n状态标识说明：\n本地新增的文件 文件的一个新拷贝 本地删除的文件 修改过的文件 (红色：未暂存；绿色：已暂存) 文件名被修改 文件类型被修改 文件未合并 (需解决冲突) 未被 Git 管理的文件 已被修改但未暂存的文件，可用 git checkout -- fileName 撤销更改。 4. 添加到暂存区 (git add) 把所有修改的信息添加到暂存区\ngit add .\n仅添加被跟踪文件中被修改或删除的信息 (不处理新文件)\ngit add -u\n添加所有变化 (修改、删除、新增)\ngit add -A\n已提交到暂存区的文件，可以通过 git reset HEAD -- fileName 撤销提交（移出暂存区）。\n5. 提交代码 (git commit) 将暂存区的修改提交到本地仓库，生成 commit-id。\n提交暂存区修改\ngit commit -m \u0026quot;message\u0026quot;\n跳过 git add，直接将工作区修改提交 (不包含新文件)\ngit commit -a -m \u0026quot;message\u0026quot;\n修改最后一次提交 (用于漏掉文件或修改 commit 信息)\ngit commit --amend\n6. 拉取与获取 (git pull \u0026amp; git fetch) git pull 获取远程更新并与本地分支合并。逻辑上等于 git fetch + git merge。\n格式: git pull \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt;\n取回远程 dev 分支与本地 master 合并\ngit pull origin dev:master\n取回远程 dev 分支与当前分支合并\ngit pull origin dev\ngit fetch 仅将远程更新取回本地，不自动合并。\n获取远程 master 分支代码\ngit fetch origin\n获取远程 master 代码到本地新建的 test 分支\ngit fetch origin master:test\n7. 推送代码 (git push) 将本地 master 分支推送到远程\ngit push origin master\n删除远程 dev 分支\ngit push origin --delete dev\n8. 分支管理 (git branch) 查看本地分支\ngit branch 查看本地和远程分支\ngit branch -a 新建分支\ngit branch test 重命名分支 (test 改为 dev)\ngit branch -m test dev 删除分支 (本地)\ngit branch -d dev\n9. 切换与撤销 (git checkout) 切换到指定 tag\ngit checkout v1.0.0\n基于 v1.0.0 创建并切换到 test 分支\ngit checkout -b test v1.0.0\n放弃工作区所有修改 (慎用)\ngit checkout .\n放弃指定文件的修改\ngit checkout -- fileName\n10. 标签管理 (git tag) 查看已有标签\ngit tag\n#给最新 commit 打标签\ngit tag v1.0.0\n#给指定 commit id 打标签\ngit tag v0.9.0 \u0026lt;commit-id\u0026gt;\n11. 查看日志 (git log) 查看详细历史\ngit log\n单行显示 (简洁)\ngit log --oneline\n查看特定作者\ngit log --author=\u0026quot;name\u0026quot;\n#图形化显示分支合并历史\ngit log --graph\n显示前 n 条\ngit log -n 5\n按日期筛选\ngit log --after=\u0026quot;2018-10-1\u0026quot;\ngit log --before=\u0026quot;2018-10-7\u0026quot;\n12. 版本回退 (git reset) git reset 用于撤销暂存区修改或本地仓库提交。\n撤销暂存区 (git add 后): git reset HEAD fileName\ngit reset HEAD .\n撤销本地提交 (git commit 后): \u0026ndash;soft: 仅重置 HEAD 指针，保留暂存区和工作区内容 (相当于撤销 commit 命令)。 \u0026ndash;mixed (默认): 重置 HEAD 指针和暂存区，保留工作区内容。 \u0026ndash;hard: 重置 HEAD、暂存区和工作区，所有修改丢失。 回退到上一个版本 git reset --soft HEAD~1\n回退到指定 commit-id\ngit reset --hard a1b2c3d\n13. 远程仓库管理 (git remote) 查看远程仓库名称\ngit remote\n查看详细信息 (fetch/push 地址)\ngit remote -v\n添加远程仓库\ngit remote add origin \u0026lt;url\u0026gt;\n删除远程关联\ngit remote remove origin\n修改远程仓库地址\ngit remote set-url origin \u0026lt;new-url\u0026gt;\n清理远程已删除分支的本地缓存\ngit remote update origin --prune\n14. 合并 (git merge) 将 dev 分支合并到当前分支 git merge dev\n15. 暂存更改 (git stash) 当需要切换分支但不想提交当前工作时使用。\n保存当前进度\ngit stash\n查看保存列表\ngit stash list\n恢复最近进度并删除记录\ngit stash pop\n恢复指定进度 (不删除记录)\ngit stash apply stash@{0}\n删除指定进度\ngit stash drop stash@{0}\n清空所有进度\ngit stash clear\n16. 忽略文件 (.gitignore) 在项目根目录创建 .gitignore 文件，列出不需要 Git 管理的文件或目录（如系统文件、编译产物、密钥等）。GitHub 提供了标准模板。\n17. 实战：新建项目并提交 初始化本地仓库: git init 添加文件到暂存区: git add . 提交到本地仓库: git commit -m \u0026quot;first commit\u0026quot; 关联远程仓库: git remote add origin https://github.com/user/repo.git 推送到远程: git push -u origin master 18. SSH 秘钥配置 检查现有秘钥: cd ~/.ssh ls 生成新秘钥: ssh-keygen -t rsa -C \u0026quot;your_email@example.com\u0026quot; 一路回车使用默认值即可。 获取公钥: cat ~/.ssh/id_rsa.pub 复制输出内容配置到 GitHub/GitLab 的 SSH Keys 中。 19. 常见问题与修复 Push 失败 (本地与远程分支不一致) 通常发生在远程\n","date":"2023-11-26T14:36:18+08:00","permalink":"https://changxiangyu.cn/p/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/","title":"Git常用命令总结"},{"content":"打造高效写作流：Markdown 与 Pandoc 的完美结合 在数字化写作的时代，我们经常面临一个痛点：内容与格式的纠缠。在 Word 中调整缩进和字体往往占据了我们一半的创作时间。今天，我想分享一套“一次编写，到处运行”的高效写作方案：Markdown + Pandoc。\n为什么选择 Markdown？ Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。它的核心优势在于：\n专注内容：没有复杂的排版按钮，让你沉浸在写作逻辑中。 通用性强：几乎所有的代码编辑器和笔记软件都支持。 版本控制：纯文本文件非常适合用 Git 进行管理。 “Markdown 的目标是实现‘易读易写’。” —— John Gruber\n神器登场：Pandoc 是什么？ 如果说 Markdown 是原材料，那么 Pandoc 就是那台万能加工机。它是一个开源的文档转换工具，被誉为文档转换界的“瑞士军刀”。\n它支持在 Markdown、Word、PDF、LaTeX、HTML 等多种格式之间相互转换。这对于写简历、论文或技术文档来说，简直是救星。\n核心功能 保留 Markdown 的结构和可读性 一键生成 PDF / Word / HTML 支持自定义 CSS 样式和 LaTeX 模板 实战演练：如何安装与使用 1. 安装 Pandoc 根据你的操作系统，选择对应的安装方式：\nWindows: 访问官网下载 .msi 安装包，记得勾选 \u0026ldquo;Add to PATH\u0026rdquo;。 MacOS: 使用 Homebrew 安装。 1 brew install pandoc Linux: 1 sudo apt install pandoc 安装完成后，在终端输入 pandoc -v 检查是否成功。\n2. 转换命令速查 假设你写好了一份名为 resume.md 的简历，以下是几个常用的转换命令：\n生成 Word 文档\npandoc resume.md -o resume.docx\n生成 PDF (推荐使用 wkhtmltopdf 引擎) 如果你希望保留 Markdown 中的 CSS 样式（比如带颜色的标题），建议使用以下命令：\n1 pandoc resume.md -o resume.pdf --pdf-engine=wkhtmltopdf 进阶技巧：套用模板 Pandoc 最强大的地方在于支持模板。你可以下载大神们做好的 LaTeX 模板，让你的文档瞬间拥有出版级的排版。\n1 pandoc resume.md -o resume.pdf --template=mytemplate.tex ","date":"2023-10-27T20:46:00+08:00","permalink":"https://changxiangyu.cn/p/markdown-%E4%B8%8E-pandoc-%E7%9A%84%E5%AE%8C%E7%BE%8E%E7%BB%93%E5%90%88/","title":"Markdown 与 Pandoc 的完美结合"},{"content":" 记录我们最珍贵的时刻，每一张都是爱的见证。\n","date":"2023-08-07T15:33:18+08:00","image":"https://changxiangyu.cn/images/photo-antique-style/1-1.jpg","permalink":"https://changxiangyu.cn/p/%E5%8F%A4%E9%A3%8E%E5%86%99%E7%9C%9F/","title":"古风写真"},{"content":"概述 本文档旨在介绍 Vue 项目（包括 Vue CLI、Vite 及 UniApp H5）构建完成后，如何使用 Nginx 进行生产环境的部署与配置。内容涵盖 Nginx 的核心配置、前端路由与路径设置、环境变量管理以及在 Windows 环境下的特殊操作指南。\n1. 前置要求 在开始部署前，请确保满足以下条件：\n构建完成：Vue 项目已完成开发，并通过流水线或本地构建命令打包生成了静态资源（通常为 dist 目录）。 环境准备：服务器已安装 Nginx。 文件部署：构建好的静态文件已上传至服务器指定目录。 2. Nginx 核心配置 以下是一个标准的 Nginx server 配置块，适用于单页应用（SPA）的部署。\n配置文件示例 (nginx.conf) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 server { listen 80; server_name test.wxy.cn; # 请替换为实际域名 # 1. 开启 Gzip 压缩（优化加载速度） gzip on; gzip_min_length 1k; gzip_comp_level 6; gzip_types text/plain text/css text/javascript application/json application/javascript application/xml+rss; gzip_vary on; gzip_disable \u0026#34;MSIE [1-6]\\.\u0026#34;; # 2. 前端静态资源托管 location / { root /usr/share/nginx/html; # 静态资源存放路径 index index.html; # 核心配置：解决 History 模式路由刷新 404 问题 try_files $uri $uri/ /index.html; } # 3. 接口反向代理配置 location /vpsmobileh5 { # 如果需要重写路径，可取消注释下面这行 # rewrite ^/vpsmobileh5(.*)$ \\$1 break; # ⚠️ 注意：proxy_pass 结尾带 / 表示去除匹配路径 proxy_pass http://172.168.50.77:16690/; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 支持 WebSocket proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;upgrade\u0026#34;; client_max_body_size 200m; expires 0; } } ⚠️ 关键注意事项 proxy_pass 的斜杠： proxy_pass http://ip:port/;（带斜杠）：会将 /vpsmobileh5/api 转发为 /api（去除了前缀）。 proxy_pass http://ip:port;（不带斜杠）：会将 /vpsmobileh5/api 转发为 /vpsmobileh5/api（保留前缀）。 3. 前端项目配置详解 为了配合 Nginx 部署，前端代码层面也需要进行相应的适配。\n3.1 路由模式与基础路径 Vue Router 主要有两种模式：hash 和 history。\n推荐配置：虽然 History 模式 URL 更美观，但若为了简化服务器配置或兼容性，Hash 模式通常更省心。 路径配置：建议设置 base 为相对路径 ./，使静态资源能自动适应部署的子目录。 配置示例 (manifest.json 或 router 配置): 1 2 3 4 5 6 7 8 { \u0026#34;h5\u0026#34; : { \u0026#34;router\u0026#34; : { \u0026#34;mode\u0026#34; : \u0026#34;hash\u0026#34;, \u0026#34;base\u0026#34;: \u0026#34;./\u0026#34; } } } 资源引用规范：\n❌ 避免使用 ../../static/icon/logo.png 这种跨层级相对路径。 ✅ 推荐使用 static/icon/logo.png 或绝对路径，确保基于当前目录结构查找。 3.2 环境变量管理 (API 基地址) 根据构建工具的不同（Vite vs Webpack/Vue CLI），环境变量的处理方式有所区别。\n场景 A：Vite 项目 (Vue 3 / UniApp)\n创建配置文件 .env.production: 1 2 3 NODE_ENV=production # 变量名必须以 VITE_ 开头 VITE_BASE_URL=http://api.prod.com 代码中调用: 1 2 3 4 5 console.log(\u0026#39;当前环境\u0026#39;, import.meta.env.MODE); export const defaultUrl = import.meta.env.MODE === \u0026#39;production\u0026#39; ? import.meta.env.VITE_BASE_URL : \u0026#39;http://172.168.50.73:6603\u0026#39;; 场景 B：Vue CLI 项目 (Vue 2)\n创建配置文件 .env.production: 1 2 3 NODE_ENV=production # 变量名必须以 VUE_APP_ 开头 VUE_APP_BASE_URL=http://api.prod.com 代码中调用: 1 2 3 4 5 console.log(\u0026#39;当前环境\u0026#39;, process.env.NODE_ENV); export const defaultUrl = process.env.NODE_ENV === \u0026#39;production\u0026#39; ? process.env.VUE_APP_BASE_URL : \u0026#39;http://172.168.81.177:9001\u0026#39;; 3.3 构建公共路径 (Vite Config) 在 vite.config.js 中配置 base，决定了 HTML 中引入 JS/CSS 的路径前缀。\n1 2 3 4 5 6 7 8 9 10 import { defineConfig } from \u0026#34;vite\u0026#34;; import uni from \u0026#34;@dcloudio/vite-plugin-uni\u0026#34;; export default defineConfig({ plugins: [uni()], base: \u0026#39;/\u0026#39;, // 默认值，表示从根路径加载。如果部署在子目录，请修改此处 server: { port: 9011, } }) 4. Windows 环境与 IIS 混合部署指南 如果您的生产环境是 Windows Server，且涉及 IIS 与 Nginx 共存，请参考以下操作。\n4.1 部署结构建议 IIS 配置：新建网站，指向项目物理路径（如 D:\\WebSite\\YKT）。 Nginx 配置：作为反向代理或静态服务器，配置文件位于 D:\\Nginx\\nginx-1.15.6\\conf\\nginx.conf。 4.2 Nginx 常用命令 (CMD) 请在 Nginx 安装目录（如 D:\\Nginx\\nginx-1.15.6）下打开 CMD 执行：\n操作 命令 说明 启动 start nginx 启动服务，在 Windows 下窗口闪退属正常现象（进程已在后台运行）。 重载 nginx -s reload 修改 nginx.conf 后，无需重启，热加载新配置。 停止 nginx -s stop 快速停止 Nginx 服务。 退出 nginx -s quit 处理完当前请求后，优雅退出服务。 检测 nginx -t 强烈推荐。在重载前运行，用于检测配置文件语法是否正确。 4.3 排查端口占用 如果启动失败，通常是端口冲突导致。\n1 2 3 4 5 # 1. 查看占用 80 端口的进程 PID netstat -aon | findstr \u0026#34;80\u0026#34; # 2. 根据 PID 查看是哪个程序 (假设 PID 为 2276) tasklist | findstr \u0026#34;2276\u0026#34; ⚠️ Windows 下的严重警告 不要使用记事本 (Notepad) 编辑 nginx.conf！ 记事本保存时会自动添加 BOM (Byte Order Mark) 头，这会导致 Nginx 读取配置文件失败。 解决方案：请使用 VS Code、Notepad++ 或 Sublime Text 等专业编辑器。\n5. 常见问题排查 (FAQ) Q1: 部署后静态资源（JS/CSS）加载 404？\n原因：构建时的 publicPath (Vue CLI) 或 base (Vite) 配置与 Nginx 的部署目录不一致。\n解决：如果部署在根目录，设置为 /；如果部署在 /app/ 子目录，设置为 /app/ 或 ./。 Q2: 环境变量不生效？\n原因：前缀错误或文件未加载。\n解决：\nVite 必须用 VITE_开头。 Vue CLI 必须用 VUE_APP_ 开头。 确保 .env.production 文件位于项目根目录。 Q3: 刷新页面出现 404 错误？ 原因：使用了 History 路由模式，但 Nginx 未配置重定向。\n解决：确保 Nginx 配置中包含 try_files $uri $uri/ /index.html;。\n","date":"2023-04-27T13:05:18+08:00","permalink":"https://changxiangyu.cn/p/vue-%E9%A1%B9%E7%9B%AE-nginx-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8E%E9%85%8D%E7%BD%AE%E5%85%A8%E6%8C%87%E5%8D%97/","title":"Vue 项目 Nginx 生产环境部署与配置全指南"},{"content":"在微前端架构中，主应用与子应用的技术栈差异往往会带来一些意想不到的路由同步问题。本文将分享一个在 Vue3 主应用 + Angular 子应用 场景下，遇到的“三级路由回退导致导航失效”的各种坑及其解决方案。\n1. 问题描述 场景\n主应用：Vue3 + Vue Router (Hash 模式) 子应用：Angular (使用 Qiankun 接入) 操作路径：进入 Angular 子应用 -\u0026gt; 进入二级页面 -\u0026gt; 进入三级页面 -\u0026gt; 点击“返回”按钮回退到上一级。 症状 当从三级路由回退后，再次点击主应用侧边栏或其他菜单时，页面无反应。查看浏览器控制台，出现类似 route undefined 的报错。 2. 原因深度分析 经过源码排查，发现问题的根源在于 Vue Router 与 Angular Router 对底层 History API 的使用差异。\nVue Router 的机制： Vue3 的路由跳转底层调用了 changeLocation 函数。该函数在执行时，高度依赖 history.state 来获取路由信息。如果 history.state 为空或缺少关键字段（如 current），Vue Router 可能无法正确识别当前位置，从而导致跳转逻辑中断。\nAngular Router 的差异： Angular 的默认路由跳转（特别是使用 HTML 中的 [routerLink]=\u0026quot;['../']\u0026quot; 指令时），并不会默认向 history.state 中写入 Vue Router 所需的元数据。\n结论：当在 Angular 子应用中进行路由回退时，由于没有正确更新 history.state，导致主应用（Vue3）接管路由时读取到了空状态或错误状态，最终引发路由报错。\n3. 解决方案 为了解决这个问题，我们需要在“子应用跳转”和“主应用监听”两个层面进行改造。\n步骤一：改造 Angular 子应用的跳转方式 核心策略：放弃 HTML 模板中的 [routerLink] 跳转，改用 API 编程式导航，并手动注入 state。\nAngular 的 Router.navigate 方法允许我们传递 NavigationExtras，其中的 state 属性可以让我们自定义路由状态。这正好可以用来模拟 Vue Router 所需的数据结构。\n代码实现 (Angular 子应用)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 在组件中注入 Router import { Router } from \u0026#39;@angular/router\u0026#39;; constructor(private _router: Router) {} // 替代原本的 [routerLink]=\u0026#34;[\u0026#39;../\u0026#39;]\u0026#34; back() { // 手动构建 state 对象，模拟 Vue Router 的 current 字段 // 注意：这里的路径需要根据实际业务调整 const state = { current: \u0026#39;/kq/kqGroup\u0026#39; }; // 使用 navigate 跳转，并带上 state this._router.navigate([\u0026#39;/kqGroup\u0026#39;], { state: state }); } 注意：建议三级路由跳转时，URL 中尽量不要直接携带参数，可以考虑通过 Service 或 State 传递数据，以减少路由匹配的复杂度。\n步骤二：改造 Vue3 主应用的路由守卫 核心策略：在主应用的全局路由守卫中，主动检测并修复 history.state。\n我们需要在 router.beforeEach 中监听路由变化。如果发现 history.state 丢失或不完整（缺少 current 字段），则使用 history.replaceState 强制补全，确保 Vue Router 能正常工作。\n代码实现 (Vue3 主应用)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 import { createRouter, createWebHashHistory } from \u0026#39;vue-router\u0026#39;; const router = createRouter({ history: createWebHashHistory(), routes, }); router.beforeEach(async (to, from, next) =\u0026gt; { // 1. 核心修复逻辑：补全 history.state // 如果 state 存在但没有 current 字段，说明可能是子应用过来的跳转，手动补全 if (history.state \u0026amp;\u0026amp; !history.state.current) { console.log(\u0026#39;检测到 state 缺失，执行 replaceState 修复\u0026#39;); window.history.replaceState({ current: to.path }, \u0026#39;\u0026#39;, to.path); } // 调试日志 console.log(\u0026#39;微前端 history.state ===\u0026#39;, history.state); console.log(\u0026#39;微前端 window.location ===\u0026#39;, window.location); // 2. 特殊业务场景修复（如巡更业务） // 修复通过菜单切换后，history.state 丢失应用前缀信息的问题 const current = history.state?.current; const pathname = window.location.pathname; if (pathname \u0026amp;\u0026amp; pathname.startsWith(\u0026#39;/xg\u0026#39;)) { if (current !== pathname) { history.replaceState( { back: from.path, current: window.location.pathname }, to.path, \u0026#39;\u0026#39; ); } } // 3. 常规鉴权与路由分发逻辑 if (!verifyToken() \u0026amp;\u0026amp; to.path !== \u0026#39;/login\u0026#39;) { // ... 处理登录逻辑 if (noLoginPage.includes(to.path)) { next(); } else { next({ path: \u0026#39;/login\u0026#39;, query: { fromPath: to.fullPath } }); } } else { // 清理缓存逻辑 if (to.path === \u0026#39;/home\u0026#39;) { sessionStorage.removeItem(\u0026#39;currentMenu\u0026#39;); sessionStorage.removeItem(\u0026#39;currentPage\u0026#39;); } // 动态路由加载逻辑 if (store.state.menus.routers.length === 0 \u0026amp;\u0026amp; to.path !== \u0026#39;/login\u0026#39;) { // 处理菜单基合菜单列表 const res = await store.dispatch(\u0026#39;menus/getMenus\u0026#39;); res.forEach((route) =\u0026gt; { if (router.hasRoute(\u0026#39;Main\u0026#39;)) { router.addRoute(\u0026#39;Main\u0026#39;, route); } }); const routers = router.getRoutes(); // Tips不检查门禁监控菜单 if (routers.find((item) =\u0026gt; item.path === to.path || /\\/monitor\\/mj\\//.test(to.path))) { next({ ...to, replace: true }); } else { next({ path: \u0026#39;/not-find\u0026#39; }); } } else { // 404 检测 const routers = router.getRoutes(); // 简单的白名单检查 if (routers.find(item =\u0026gt; item.path === to.path || /\\/monitor\\/mj\\//.test(to.path))) { next(); } else { next({ path: \u0026#39;/not-find\u0026#39; }); } } } }); 4. 总结 在乾坤微前端架构中，不同框架对 History API 的操作习惯不同是导致路由不同步的常见原因。\nAngular 侧：利用 navigate 的 state 参数主动配合主应用的路由机制。 Vue 侧：利用 beforeEach 守卫进行兜底，确保 history.state 始终包含 current 字段。 通过双向奔赴的改造，我们成功解决了三级路由回退后的“死锁”问题，保证了微前端应用的流畅体验。 ","date":"2023-04-27T13:05:18+08:00","permalink":"https://changxiangyu.cn/p/%E4%B9%BE%E5%9D%A4qiankun%E5%BE%AE%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/","title":"乾坤(Qiankun)微前端路由"},{"content":"本文总结了前端开发中常见的微信支付三种接入场景及其核心流程。\n1. 公众号支付 (JSAPI) 适用场景：微信内置浏览器、微信客户端扫码、企业微信网页。\n核心流程 网页授权获取 Code： 引导用户访问微信授权链接，获取 code。 1 https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID\u0026amp;redirect_uri=REDIRECT_URI\u0026amp;response_type=code\u0026amp;scope=snsapi_base\u0026amp;state=123#wechat_redirect 获取 OpenID： 后端使用 appid、secret 和前端传来的 code 换取用户的 openid。 统一下单： 后端调用微信统一下单接口，获取支付参数（timeStamp, nonceStr, package, signType, paySign）。 唤起支付： 前端使用 WeixinJSBridge.invoke 或 wx.chooseWXPay 调起支付窗口。 ⚠️ 注意事项 授权域名：redirect_uri 的域名必须在微信公众平台的“网页授权域名”中配置。 支付目录：支付页面的路径必须在微信商户平台配置“JSAPI支付授权目录”。 AppID：此处使用公众号的 AppID。 2. H5 支付 适用场景：外部移动端浏览器（如 Safari, Chrome）、App 内嵌 H5（非微信环境）。\n核心流程 后端下单： 后端调用微信统一下单接口（交易类型为 MWEB）。 获取跳转链接： 接口返回 mweb_url（即原文中的 pay_url）。 跳转支付： 前端直接跳转该链接，微信会中间页唤起微信客户端进行支付。 1 2 // 示例：跳转并指定支付后的回调页 window.location.href = mweb_url + \u0026#39;\u0026amp;redirect_url=\u0026#39; + encodeURIComponent(window.location.href); ⚠️ 注意事项 Referer 校验：微信会校验发起支付请求的域名（Referer），需在商户平台配置“H5支付域名”。 AppID：此处使用商户绑定的移动应用或公众号 AppID。 3. 小程序支付 适用场景：微信小程序原生环境。\n核心流程 获取登录凭证： 前端调用 wx.login() 获取 code。 获取 OpenID： 后端通过 appid、secret 和 code 换取 openid。 后端下单： 后端调用统一下单接口，返回支付核心参数（paySign 等）。 唤起支付： 前端调用小程序 API 进行支付： 1 2 3 4 5 6 7 8 9 wx.requestPayment({ timeStamp: \u0026#39;\u0026#39;, nonceStr: \u0026#39;\u0026#39;, package: \u0026#39;\u0026#39;, signType: \u0026#39;MD5\u0026#39;, paySign: \u0026#39;\u0026#39;, success (res) { }, fail (res) { } }) ⚠️ 注意事项 AppID：此处必须使用小程序的 AppID。 账号关联：小程序必须已关联到微信商户号。 4. 附录：前端环境判断工具 在发起支付前，我们需要根据当前运行环境（User Agent）来决定调用 JSAPI 支付还是 H5 支付。可以使用以下工具函数进行判断：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** * 获取当前运行平台 * @returns {string} \u0026#39;wecom\u0026#39; | \u0026#39;wechat\u0026#39; | \u0026#39;h5\u0026#39; */ function getPlat() { const ua = window.navigator.userAgent.toLowerCase(); if (ua.includes(\u0026#39;wxwork\u0026#39;)) { return \u0026#39;wecom\u0026#39;; // 企业微信环境（需使用企业微信JS-SDK或兼容JSAPI） } else if (ua.includes(\u0026#39;micromessenger\u0026#39;)) { return \u0026#39;wechat\u0026#39;; // 微信内置浏览器（使用 JSAPI 支付） } else { return \u0026#39;h5\u0026#39;; // 普通浏览器（使用 H5 支付） } } // 业务逻辑调用示例 const platform = getPlat(); if (platform === \u0026#39;wechat\u0026#39; || platform === \u0026#39;wecom\u0026#39;) { // 执行 JSAPI 支付逻辑 console.log(\u0026#34;检测到微信环境，准备唤起 JSAPI 支付\u0026#34;); // doJSAPIPay(); } else { // 执行 H5 支付逻辑 console.log(\u0026#34;检测到外部浏览器，准备唤起 H5 支付\u0026#34;); // doH5Pay(); } 补充说明 企业微信兼容性：在企业微信（wxwork）中，通常也兼容微信的 JSAPI 支付，但建议参考企业微信官方文档确认是否需要引入特定的 jweixin-module。 小程序环境判断：如果您还需要判断是否在小程序 Webview 中，可以增加一个判断条件： 1 2 3 if (ua.includes(\u0026#39;miniprogram\u0026#39;) || window.__wxjs_environment === \u0026#39;miniprogram\u0026#39;) { return \u0026#39;miniprogram\u0026#39;; } ","date":"2023-03-12T13:05:18+08:00","permalink":"https://changxiangyu.cn/p/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97jsapih5%E4%B8%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F/","title":"微信支付接入指南：JSAPI、H5与小程序"},{"content":"uniapp项目H5发行（发行-\u0026gt;网站-PC web或手机H5）打包后\n如果要给项目封装一个请求，但请求地址必须读取配置文件，从配置文件中拿地址，后续随时更改配置文件，直接让请求地址发生变化。\n解决方案 核心思路：利用打包后的index.html文件，原生\u0026lt;script\u0026gt;引入配置文件，在全局可调用。 uniapp 官方解决方案（建议看一眼）：\n建立一个config.js配置文件： var config = { defaultUrl: \u0026quot;https://c3test.dassoft.cn\u0026quot;, tenantCode: \u0026quot;admin\u0026quot; }\n保存到桌面上即可，无需放到项目中。 在项目根目录新建temp.h5.html空文件，cli创建的话同理 打开temp.h5.html复制以下模板代码，\u0026lt;script\u0026gt;引入配置文件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt; \u0026lt;%= htmlWebpackPlugin.options.title %\u0026gt; \u0026lt;/title\u0026gt; \u0026lt;!-- Open Graph data --\u0026gt; \u0026lt;!-- \u0026lt;meta property=\u0026#34;og:title\u0026#34; content=\u0026#34;Title Here\u0026#34; /\u0026gt; --\u0026gt; \u0026lt;!-- \u0026lt;meta property=\u0026#34;og:url\u0026#34; content=\u0026#34;http://www.example.com/\u0026#34; /\u0026gt; --\u0026gt; \u0026lt;!-- \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;http://example.com/image.jpg\u0026#34; /\u0026gt; --\u0026gt; \u0026lt;!-- \u0026lt;meta property=\u0026#34;og:description\u0026#34; content=\u0026#34;Description Here\u0026#34; /\u0026gt; --\u0026gt; \u0026lt;script\u0026gt; var coverSupport = \u0026#39;CSS\u0026#39; in window \u0026amp;\u0026amp; typeof CSS.supports === \u0026#39;function\u0026#39; \u0026amp;\u0026amp; (CSS.supports(\u0026#39;top: env(a)\u0026#39;) || CSS.supports(\u0026#39;top: constant(a)\u0026#39;)) document.write(\u0026#39;\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\u0026#39; + (coverSupport ? \u0026#39;, viewport-fit=cover\u0026#39; : \u0026#39;\u0026#39;) + \u0026#39;\u0026#34; /\u0026gt;\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;\u0026lt;%= BASE_URL %\u0026gt;static/index.\u0026lt;%= VUE_APP_INDEX_CSS_HASH %\u0026gt;.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;noscript\u0026gt; \u0026lt;strong\u0026gt;Please enable JavaScript to continue.\u0026lt;/strong\u0026gt; \u0026lt;/noscript\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- built files will be auto injected --\u0026gt; \u0026lt;script language=\u0026#34;javascript\u0026#34;\u0026gt; //使用了 sessionStorage和时间戳，这样可以防止 js和css的缓存,页面会话刷新时间为半小时 var timestamp = new Date().getTime(); var versionStamp = sessionStorage.version; if (versionStamp == null || (timestamp - versionStamp) \u0026gt; 1800000) { sessionStorage.version = timestamp; } document.write(\u0026#39;\u0026lt;script src=\u0026#34;./config.js?v=\u0026#39; + sessionStorage.version + \u0026#39;\u0026#34;\u0026gt;\u0026lt;\\/script\\\u0026gt;\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;``` 提前写好获取配置文件的代码（在哪里用配置文件就在那里写）\nexport const defaultUrl = config.defaultUrl;\n开发中，可以先写死参数，后续要打包后在变更。 打开manifest.json文件，将temp.h5.html关联： 都配置好后，执行编辑器菜单-\u0026gt;发行-\u0026gt;网站-PC web或手机H5,进行打包： 打包完成后，把h5目录复制到桌面，如下图所示文件夹位置。 将配置文件config.js加入到根目录，确保与index.html同级 此时index.html中的\u0026lt;script src=\u0026quot;./config.js\u0026gt;就能正确找到配置文件，从而实现读取。 可以改变config.js文件配置，然后刷新浏览器页面，查看是否更改。 ","date":"2023-01-25T13:05:18+08:00","permalink":"https://changxiangyu.cn/p/uniapp-h5%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","title":"uniapp-h5自定义配置文件"},{"content":"服务产生大量core文件，导致存储空间被占满 可通过命令find /home/docker -name core.*查看产生core文件的路径（docker数据目录以现场配置为准）\n删除所有容器，包含base和c3目录下的 docker-compose down 使用df -h检查空间是否已经恢复 修改docker-compose.yml,在每个服务的最后增加以下配置： 1 2 ulimits: core: 0 5. 启动docker容器 docker-compose up -d\n","date":"2023-01-17T11:02:00+08:00","permalink":"https://changxiangyu.cn/p/docker%E5%AE%B9%E5%99%A8%E5%8D%A0%E7%94%A8%E5%A4%A7%E9%87%8F%E5%AD%98%E5%82%A8/","title":"Docker容器占用大量存储"},{"content":"在 Uniapp 开发 H5 应用时，涉及到手机拍照上传的功能往往会遇到两个棘手的问题：\n图片方向不对：不同厂商的手机（尤其是 iOS 和部分 Android）在拍照时，图片实际上是“横着”保存的，通过 EXIF 信息标记了方向。直接在 img 标签显示可能正常，但一旦绘制到 Canvas 或上传到服务器，图片就会歪掉（通常是旋转了 90 度）。 图片体积过大：手机原图动辄 5MB+，直接上传消耗流量且速度慢，需要在前端进行压缩。 本文将分享一个基于 Exif.js 和 Canvas 的完整解决方案。\n准备工作 我们需要引入两个核心工具库：\nExif.js：用于读取图片的元数据（Metadata），核心是获取 Orientation（方向）标识。 Mobile-detect（可选）：用于辅助判断设备类型，处理特定机型的兼容性差异。 1. 引入 Exif.js 由于 exif.js 是一个较老的库，建议将其源码保存到项目中，例如 common/js/toolJs/exif.js。 (注：由于源码较长，此处不贴出完整库代码，请直接下载官方版本或使用 npm 安装)\n2. 核心组件实现 我们将功能封装在一个 Vue 组件中。主要流程如下： 选择图片 -\u0026gt; 读取EXIF方向 -\u0026gt; Canvas重绘(旋转+压缩) -\u0026gt; 获取Base64 -\u0026gt; 上传。\nHTML 结构 简单的界面，包含预览图、拍照按钮和上传按钮。\n1 2 3 4 5 6 7 8 html \u0026lt;template\u0026gt; \u0026lt;view class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;image :src=\u0026#34;photoSrc\u0026#34; mode=\u0026#34;aspectFit\u0026#34; style=\u0026#34;width: 100%; height: 300px;\u0026#34;\u0026gt;\u0026lt;/image\u0026gt; \u0026lt;button type=\u0026#34;primary\u0026#34; @click=\u0026#34;takePhoto\u0026#34;\u0026gt;拍照/选图\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;primary\u0026#34; @click=\u0026#34;uploadPhoto\u0026#34; :disabled=\u0026#34;!photoSrc\u0026#34;\u0026gt;上传\u0026lt;/button\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; 核心 JS 逻辑 首先引入必要的库：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import EXIF from \u0026#39;../../common/js/toolJs/exif.js\u0026#39;; import MobileDetect from \u0026#39;mobile-detect\u0026#39;; export default { data() { return { photoSrc: \u0026#39;\u0026#39;, } }, methods: { // ...后续方法 } } 关键步骤解析 获取图片并开启处理流程 使用 uni.chooseImage 获取图片，然后调用 detail 方法进行处理。 1 2 3 4 5 6 7 8 9 10 11 12 takePhoto() { uni.chooseImage({ count: 1, success: async (res) =\u0026gt; { // 开启异步处理流程 this.photoSrc = await this.detail(res.tempFilePaths[0]) }, fail: (res) =\u0026gt; { console.error(res) } }) }, 读取 EXIF Orientation 信息 这是修正方向的关键。我们需要封装一个 Promise 方法来读取图片的 Orientation 标签。 1: 正常 6: 顺时针旋转90度 8: 逆时针旋转90度 3: 旋转180度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 getImageTag(file, tag, suc) { if (!file) return 0; return new Promise((resolve, reject) =\u0026gt; { let imgObj = new Image() imgObj.src = file uni.getImageInfo({ src: file, success(res) { EXIF.getData(imgObj, function() { EXIF.getAllTags(this); // 获取方向标记 let or = EXIF.getTag(this, \u0026#39;Orientation\u0026#39;); resolve(suc(or)) }); } }) }); }, Canvas 旋转与压缩 这是最复杂的环节。我们需要根据 Orientation 的值，利用 Canvas 的 rotate 方法将图片“扳正”。同时，通过控制 Canvas 的尺寸来实现压缩。 注意：代码中加入了一个 getPlat() 判断，这是因为在实际测试中发现，部分 Android 环境下 Canvas 的旋转行为可能与 iOS 不一致，需要做特殊处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // 判断是否为 Android 终端 getPlat() { let u = navigator.userAgent; return u.indexOf(\u0026#39;Android\u0026#39;) \u0026gt; -1 || u.indexOf(\u0026#39;Adr\u0026#39;) \u0026gt; -1; }, async detail(url) { let maxWidth = 800; // 设置最大宽度进行压缩 let Orientation = 1; // 1. 获取方向 await this.getImageTag(url, \u0026#39;Orientation\u0026#39;, function(e) { if (e != undefined) Orientation = e; }) var img = null; var canvas = null; // 2. 加载图片资源 await this.comprossImage(url, maxWidth, function(e) { img = e.img; canvas = e.canvas; }) console.log(\u0026#34;图片方向角:\u0026#34;, Orientation) let baseStr = \u0026#39;\u0026#39;; // 3. 根据方向角进行旋转修正 // 注意：这里针对不同平台做了一些特定逻辑处理（根据实际调试情况调整） switch (Orientation) { case 6: // 需要顺时针（向右）90度 baseStr = this.getPlat() ? this.rotateImg(img, \u0026#39;right\u0026#39;, canvas) : this.rotateImg(img, \u0026#39;\u0026#39;, canvas); // 某些安卓机型可能不需要手动旋，视具体Webview内核而定 break; case 8: // 需要逆时针（向左）90度 baseStr = this.getPlat() ? this.rotateImg(img, \u0026#39;left\u0026#39;, canvas) : this.rotateImg(img, \u0026#39;\u0026#39;, canvas); break; case 3: // 180度 baseStr = this.rotateImg(img, \u0026#39;right\u0026#39;, canvas, 2); break; default: baseStr = this.rotateImg(img, \u0026#39;\u0026#39;, canvas); break; } return baseStr; }, 旋转的具体实现 (rotateImg) 利用 Canvas 上下文的 rotate 和 drawImage。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 rotateImg(img, direction, canvas, times = 1) { // ...初始化参数，计算宽高... var width = img.width; var height = img.height; // 压缩逻辑：限制最大宽度 let maxWidth = 800; if (width \u0026gt; maxWidth) { height = Math.floor(height * (maxWidth / width)); width = maxWidth; } // 旋转角度计算 var step = 0; if (direction == \u0026#39;right\u0026#39;) step += times; else if (direction == \u0026#39;left\u0026#39;) step -= times; var degree = step * 90 * Math.PI / 180; var ctx = canvas.getContext(\u0026#39;2d\u0026#39;); switch (step) { case 1: // 旋转90度 canvas.width = height; canvas.height = width; ctx.rotate(degree); ctx.drawImage(img, 0, -height, width, height); break; case 2: // 旋转180度 canvas.width = width; canvas.height = height; ctx.rotate(degree); ctx.drawImage(img, -width, -height, width, height); break; case 3: // 旋转270度（-90度） canvas.width = height; canvas.height = width; ctx.rotate(degree); ctx.drawImage(img, -width, 0, width, height); break; default: // 不旋转 canvas.width = width; canvas.height = height; ctx.drawImage(img, 0, 0, width, height); break; } // 输出压缩后的 Base64，quality 设置为 0.8 return canvas.toDataURL(\u0026#34;image/jpeg\u0026#34;, 0.8); } 上传逻辑 最后，将获取到的 Base64 字符串（去除头部信息后）发送给后端。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 uploadPhoto() { if (!this.photoSrc) { return; } let obj = { // 去除 base64 头部，后端通常只需要内容 Photo: this.photoSrc.split(\u0026#39;;base64,\u0026#39;)[1], TimeStamp: new Date().getTime(), // ...其他业务参数 }; // 发起请求 // this.$http.baseRequest(...) } 遇到的坑与总结 Canvas 宽高混淆：当图片旋转 90 度时，Canvas 的 width 和 height 必须互换，否则图片会被裁剪或拉伸。 Android 兼容性：代码中 this.getPlat() 的判断非常重要。部分 Android 手机的 WebView 或者浏览器在上传图片时会自动修正方向，如果我们再手动旋转一次，图片反而会歪掉。建议在真机上多测试几款主流机型。 内存溢出：对于超大分辨率的图片（如 4000x3000），Canvas 绘制可能会导致 iOS Webview 崩溃（OOM）。解决方案是在绘制前先大幅度压缩图片尺寸（如限制 maxWidth）。 通过以上方案，我们不仅解决了图片“歪脖子”的问题，还实现了前端压缩，大大减轻了服务器带宽压力。\n","date":"2023-01-09T10:00:00+08:00","permalink":"https://changxiangyu.cn/p/uniapp-h5%E7%AB%AF%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E6%8B%8D%E7%85%A7%E6%97%8B%E8%BD%AC%E4%B8%8E%E5%8E%8B%E7%BC%A9%E4%B8%8A%E4%BC%A0%E6%96%B9%E6%A1%88/","title":"Uniapp H5端解决图片拍照旋转与压缩上传方案"},{"content":"Step 1: 界面代码实现 1 2 3 4 5 6 7 8 9 \u0026lt;template\u0026gt; \u0026lt;view class=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;btn\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;picture-img\u0026#34; ref=\u0026#34;uploadContent\u0026#34; id=\u0026#34;uploadContent\u0026#34; @click=\u0026#34;takePhotos()\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;loader-19\u0026#34; v-if=\u0026#34;loader\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;点击修改 \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; Step 2: 使用到的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 takePhotos() { const _that = this; if (document.getElementById(\u0026#34;take-picture\u0026#34;) == null) { let input = _that.createInputAndSetAttribute(); _that.$refs.uploadContent.$el.appendChild(input); input.onchange = async (event) =\u0026gt; { _that.loader = true; var files = event.target.files if (files \u0026amp;\u0026amp; files.length \u0026gt; 0) { const file = files[0]; // 压缩图片需要的一些元素和对象 var reader = new FileReader(), img = new Image(); // 缩放图片需要的canvas var canvas = document.createElement(\u0026#39;canvas\u0026#39;); var context = canvas.getContext(\u0026#39;2d\u0026#39;); // base64地址图片加载完毕后 img.onload = function() { // 图片原始尺寸 var originWidth = this.width; var originHeight = this.height; // 最大尺寸限制 var maxWidth = 960, maxHeight = 1280; // 目标尺寸 var targetWidth = originWidth, targetHeight = originHeight; // 图片尺寸超过400x400的限制 if (originWidth \u0026gt; maxWidth || originHeight \u0026gt; maxHeight) { if (originWidth / originHeight \u0026gt; maxWidth / maxHeight) { // 更宽，按照宽度限定尺寸 targetWidth = maxWidth; targetHeight = Math.round(maxWidth * (originHeight / originWidth)); } else { targetHeight = maxHeight; targetWidth = Math.round(maxHeight * (originWidth / originHeight)); } } // canvas对图片进行缩放 canvas.width = targetWidth; canvas.height = targetHeight; // 清除画布 context.clearRect(0, 0, targetWidth, targetHeight); // 图片压缩 context.drawImage(img, 0, 0, targetWidth, targetHeight); // canvas转为blob并上传 canvas.toBlob(async (blob) =\u0026gt; { const newFile = new File([blob], \u0026#39;123.jpg\u0026#39;, { type: blob.type }) const imgPath = await upload(newFile, file.path, `/qy/photo`) const detectionRes = await detection(imgPath) await editFacePhoto(detectionRes).then(res =\u0026gt; { if (res.code === 0) { _that.photoSrc = res.imgUrl _that.$u.toast(\u0026#34;上传成功！\u0026#34;, 2000) } else { _that.$u.toast(res.msg, 3000) } }) _that.loader = false _that.removeDocument() }, file.type || \u0026#39;image/png\u0026#39;); }; // 文件base64化，以便获知图片原始尺寸 reader.onload = function(e) { img.src = e.target.result; }; reader.readAsDataURL(file); } } } document.querySelector(\u0026#34;#take-picture\u0026#34;).click(); } // 创建input并设置input的属性 createInputAndSetAttribute() { var input = document.createElement(\u0026#39;input\u0026#39;); input.type = \u0026#39;file\u0026#39;; input.id = \u0026#39;take-picture\u0026#39; input.accept = \u0026#39;image/*\u0026#39;; // input.capture = \u0026#39;user\u0026#39;; input.style.opacity = 0; input.style.position = \u0026#39;absolute\u0026#39;; input.style.top = 0; input.style.left = 0; input.style.width = \u0026#39;50px\u0026#39;; input.style.height = \u0026#39;50px\u0026#39;; return input; } // 移除input节点 removeDocument() { const uploadContent = document.getElementById(\u0026#34;uploadContent\u0026#34;); const takePicture = document.getElementById(\u0026#34;take-picture\u0026#34;); uploadContent.removeChild(takePicture); } 可参考： https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file\n目前的实现方式有几个优化点： Vue 违规操作：在 Vue/Uniapp 中频繁使用 document.createElement、appendChild 和 removeChild 是不推荐的（这是 jQuery 时代的思维），应该利用 Vue 的模板语法。 回调地狱：FileReader、Image.onload、canvas.toBlob 层层嵌套，代码难以维护。 逻辑耦合：压缩逻辑、上传逻辑和 UI 交互混在一起。 以下是优化后的版本，采用 Vue 数据驱动 的方式，并将压缩逻辑封装为 Promise，使代码清晰易读。 优化思路 移除 DOM 操作：将 \u0026lt;input type=\u0026quot;file\u0026quot;\u0026gt; 直接写在 \u0026lt;template\u0026gt; 中并通过 v-show 隐藏，通过 ref 触发点击，避免动态创建销毁 DOM。 异步扁平化：将图片加载和 Canvas 压缩逻辑封装成 Promise，使用 async/await 替代回调函数。 功能拆分：将“选择图片”、“压缩图片”、“上传业务”拆分为独立方法。 Step 1: 界面代码实现 使用 ref 引用隐藏的 input 元素，保持页面结构整洁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;template\u0026gt; \u0026lt;view class=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;btn\u0026#34;\u0026gt; \u0026lt;!-- 触发按钮 --\u0026gt; \u0026lt;view class=\u0026#34;picture-img\u0026#34; @click=\u0026#34;triggerSelect\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;loader-19\u0026#34; v-if=\u0026#34;loader\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; {{ loader ? \u0026#39;处理中...\u0026#39; : \u0026#39;点击修改\u0026#39; }} \u0026lt;/view\u0026gt; \u0026lt;!-- 隐藏的原生Input，用于H5调用相机/文件 --\u0026gt; \u0026lt;!-- accept=\u0026#34;image/*\u0026#34; 限制图片，capture=\u0026#34;user\u0026#34; 可选：强制调用前置摄像头 --\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; ref=\u0026#34;fileInput\u0026#34; accept=\u0026#34;image/*\u0026#34; class=\u0026#34;hidden-input\u0026#34; @change=\u0026#34;handleFileChange\u0026#34; /\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style scoped\u0026gt; .hidden-input { display: none; /* 隐藏input */ } /* 你的其他样式... */ \u0026lt;/style\u0026gt; Step 2: 逻辑实现 (Script) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 export default { data() { return { loader: false, photoSrc: \u0026#39;\u0026#39; }; }, methods: { // 1. 触发文件选择 triggerSelect() { // 在Uniapp H5中，通过$refs获取原生DOM元素并点击 // 注意：App端不支持此操作，App端请使用 uni.chooseImage this.$refs.fileInput.click(); }, // 2. 监听文件改变 async handleFileChange(event) { const files = event.target.files; if (!files || files.length === 0) return; this.loader = true; const file = files[0]; try { // A. 压缩图片 const { blob, filename } = await this.compressImage(file); // B. 构造新的File对象 (解决部分浏览器兼容性) const newFile = new File([blob], filename || \u0026#39;compressed.jpg\u0026#39;, { type: blob.type }); // C. 执行上传业务 await this.uploadProcess(newFile, file.path); // file.path 在H5 input中可能不存在，视业务需求调整 } catch (error) { console.error(\u0026#34;处理失败\u0026#34;, error); this.$u.toast(\u0026#34;图片处理失败\u0026#34;, 2000); } finally { this.loader = false; // 清空value，确保下次选择同一张图也能触发change事件 event.target.value = \u0026#39;\u0026#39;; } }, // 3. 核心：图片压缩工具函数 (返回Promise) compressImage(file) { return new Promise((resolve, reject) =\u0026gt; { const reader = new FileReader(); reader.readAsDataURL(file); reader.onload = (e) =\u0026gt; { const img = new Image(); img.src = e.target.result; img.onload = () =\u0026gt; { // 原始尺寸 const originWidth = img.width; const originHeight = img.height; // 目标尺寸配置 const maxWidth = 960; const maxHeight = 1280; let targetWidth = originWidth; let targetHeight = originHeight; // 计算缩放比例 if (originWidth \u0026gt; maxWidth || originHeight \u0026gt; maxHeight) { if (originWidth / originHeight \u0026gt; maxWidth / maxHeight) { targetWidth = maxWidth; targetHeight = Math.round(maxWidth * (originHeight / originWidth)); } else { targetHeight = maxHeight; targetWidth = Math.round(maxHeight * (originWidth / originHeight)); } } // Canvas 绘制 const canvas = document.createElement(\u0026#39;canvas\u0026#39;); const context = canvas.getContext(\u0026#39;2d\u0026#39;); canvas.width = targetWidth; canvas.height = targetHeight; context.clearRect(0, 0, targetWidth, targetHeight); context.drawImage(img, 0, 0, targetWidth, targetHeight); // 导出 Blob canvas.toBlob((blob) =\u0026gt; { if (blob) { resolve({ blob, filename: file.name }); } else { reject(new Error(\u0026#39;Canvas to Blob failed\u0026#39;)); } }, file.type || \u0026#39;image/jpeg\u0026#39;, 0.8); // 0.8 为压缩质量 }; img.onerror = (err) =\u0026gt; reject(err); }; reader.onerror = (err) =\u0026gt; reject(err); }); }, // 4. 上传业务逻辑 async uploadProcess(file, originalPath) { // 假设 upload, detection, editFacePhoto 已导入或定义 const imgPath = await upload(file, originalPath, `/qy/photo`); const detectionRes = await detection(imgPath); const res = await editFacePhoto(detectionRes); if (res.code === 0) { this.photoSrc = res.imgUrl; this.$u.toast(\u0026#34;上传成功！\u0026#34;, 2000); } else { this.$u.toast(res.msg, 3000); } } } } 关键改进点说明 Input 复用： 原代码每次点击都 createElement，不仅性能低，而且在部分安卓 WebView 中可能因为 DOM 未完全插入而无法唤起相机。 新代码将 \u0026lt;input\u0026gt; 静态化，利用 event.target.value = '' 重置状态，确保稳定性。 Promise 封装： 原代码在 img.onload 内部嵌套了大量业务逻辑。 新代码将压缩逻辑提取为 compressImage，返回 Promise，使得主流程 handleFileChange 可以使用 await 顺序执行，逻辑一目了然。 兼容性处理： 增加了 canvas.toBlob 的质量参数（0.8），可进一步减小体积。 增加了 input 的 display: none 样式，避免页面出现奇怪的占位。 ","date":"2022-12-30T13:05:18+08:00","permalink":"https://changxiangyu.cn/p/uniapp%E6%8B%8D%E7%85%A7%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87h5/","title":"uniapp拍照上传图片h5"},{"content":" 参考: https://cloud.tencent.com/document/product/400/35244\n环境 1 2 ~$ nginx -v nginx version: nginx/1.18.0 (Ubuntu) 申请 SSL 证书 腾讯云\n下载 Nginx 服务器类型\n解压发送\n1 scp {chenjinxin.cn_bundle.crt,chenjinxin.cn.key} root@changxiangyu.cn:/usr/share/nginx/ 编辑服务器 Nginx 配置文件 /etc/nginx/nginx.conf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 user www-data; worker_processes auto; pid /run/nginx.pid; include /etc/nginx/modules-enabled/*.conf; events { worker_connections 768; # multi_accept on; } http { # changxiangyu.cn server { listen\t80; listen [::]:80; server_name changxiangyu.cn www.changxiangyu.cn; #把http的域名请求转成https return 301 https://$host$request_uri; #location / { #\troot /home/sammy/blog/public; #} #location /images { #\troot /home/sammy/data/; #\tautoindex on; #} } server { listen 443 ssl; ssl_certificate /usr/share/nginx/changxiangyu.cn_bundle.crt; ssl_certificate_key /usr/share/nginx/changxiangyu.cn.key; ssl_session_timeout 5m; #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #请按照以下协议配置 ssl_protocols TLSv1.2 TLSv1.3; ssl_prefer_server_ciphers on; server_name changxiangyu.cn www.changxiangyu.cn; location / { root /home/sammy/blog/public; } location /images { root /home/sammy/data/; autoindex on; } } # chenjinxin.cn server { listen\t80; listen [::]:80; server_name chenjinxin.cn www.chenjinxin.cn; #把http的域名请求转成https return 301 https://$host$request_uri; } server { listen 443 ssl; ssl_certificate /usr/share/nginx/chenjinxin.cn_bundle.crt; ssl_certificate_key /usr/share/nginx/chenjinxin.cn.key; ssl_session_timeout 5m; #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #请按照以下协议配置 ssl_protocols TLSv1.2 TLSv1.3; ssl_prefer_server_ciphers on; server_name chenjinxin.cn www.chenjinxin.cn; location / { root /home/sammy/cjx_blog/public; } location /images { root /home/sammy/data/; autoindex on; } } ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; ## # Gzip Settings ## gzip on; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; } #mail { #\t# See sample authentication script at: #\t# http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript # #\t# auth_http localhost/auth.php; #\t# pop3_capabilities \u0026#34;TOP\u0026#34; \u0026#34;USER\u0026#34;; #\t# imap_capabilities \u0026#34;IMAP4rev1\u0026#34; \u0026#34;UIDPLUS\u0026#34;; # #\tserver { #\tlisten localhost:110; #\tprotocol pop3; #\tproxy on; #\t} # #\tserver { #\tlisten localhost:143; #\tprotocol imap; #\tproxy on; #\t} #} 验证配置文件问题 1 sudo /usr/sbin/nginx -t 重载 Nginx 1 sudo /usr/sbin/nginx -s reload 成功后即可使用 chenjinxin.cn 进行访问\n","date":"2022-10-05T20:46:00+08:00","permalink":"https://changxiangyu.cn/p/%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%91%E5%AE%9A%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D/","title":"单服务器绑定多个域名"},{"content":"更新源 1 sudo apt-get update 安装ssh服务 1 sudo apt-get install openssh-server 验证SSH服务 1 sudo systemctl status ssh 创建密钥 1 ssh-keygen ","date":"2022-09-13T14:44:00+08:00","permalink":"https://changxiangyu.cn/p/ssh%E6%9C%8D%E5%8A%A1/","title":"ssh服务"},{"content":" 参考: https://www.jianshu.com/p/dc7e86b171cb\n安装软件工具 1 2 pip install requests pip install bypy 授权登陆 执行 bypy info，显示下边信息，根据提示，通过浏览器访问下边灰色的https链接，如果此时百度网盘账号正在登陆，会出现长串授权码，复制。\n1 2 3 4 5 6 [root@yu~]# bypy info Please visit: # 访问下边这个连接，复制授权码 https://openapi.baidu.com/oauth/2.0/authorize?scope=basic+netdisk\u0026amp;redirect_uri=oob\u0026amp;response_type=code\u0026amp;client_id=q8WE4EpCsau1oS0MplgMKNBn And authorize this app Paste the Authorization Code here within 10 minutes. Press [Enter] when you are done # 提示在下边粘贴授权码 在下边图示位置粘贴授权码，耐心等待一会即可\n1 2 3 4 5 Press [Enter] when you are done 2d2416c9e27c5b19f14da97c82daf18e Authorizing, please be patient, it may take upto 300 seconds... Quota: 14.020TB Used: 5.497TB 授权成功。\n测试上传和同步本地文件到云盘 由于百度PCS API权限限制，程序只能存取百度云端/apps/bypy目录下面的文件和目录。我们可以通过：\n1 2 [root@yu~]# bypy list /apps/bypy ($t $f $s $m $d): 把本地当前目录下的文件同步到百度云盘：\n1 bypy upload 把云盘上的内容同步到本地:\n1 bypy downdir 比较本地当前目录和云盘根目录，看是否一致，来判断是否同步成功：\n1 bypy compare ","date":"2022-09-07T14:18:00+08:00","permalink":"https://changxiangyu.cn/p/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98/","title":"Linux命令行上传文件到百度网盘"},{"content":"参考: https://blog.csdn.net/nklinsirui/article/details/104673286\nSSH远程执行脚本报错 SSH 远程执行脚本报错\u0026quot;command not found\u0026quot;。在宿主机可以执行命令。\n原因是之前将环境变量配置在了 /etc/profile 中，但是SSH远程执行脚本时实际上执行的是 non-login shell，而 non-login shell不会读取 /etc/profile 配置文件，只读取 ~/.bashrc。\nlogin shell和non-login shell 用SSH客户端登陆Linux系统时，要求输入用户名/密码登录或根据SSH key登录时，就是login shell。\n而在A机器上再用SSH免密码登录B机器，在B机器上执行Shell脚本，就是non-login shell。\n用Ansible在目标机器上远程执行Shell脚本时，也是non-login shell，因为Ansible是基于SSH的。\nlogin shell和non-login shell读取的环境变量配置文件 login-shell读取环境变量配置文件：\n/etc/profile ~/.bash_profile ~/.profile ~/.bashrc /etc/bashrc 注意：~/.bash_profile中已经引入了~/.bashrc，而~/.bashrc引入了/etc/bashrc，因此login shell可以读取到~/.bashrc和/etc/bashrc的配置。\n1 2 3 4 # Get the aliases and functions if [ -f ~/.bashrc ]; then . ~/.bashrc fi non-login shell读取环境变量配置文件：\n/etc/bashrc ~/.bashrc 解决non-login shell的环境配置问题 方法一：\n将login-shell和non-login shell都需要的环境配置放在~/.bashrc中，其它配置放在~/.bash_profile中。\n方法二：\n如果环境配置只放在~/.bash_profile中，需要执行non-login shell时先source ~/.bash_profile再执行命令。\n方法三：\n在 ~/.bashrc 里添加: . /etc/profile。（立即生效需要: source ~/.bashrc）\n","date":"2022-09-06T11:33:18+08:00","permalink":"https://changxiangyu.cn/p/ssh%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E6%8A%A5%E9%94%99command-not-found%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/","title":"SSH远程执行脚本报错command not found和环境变量问题"},{"content":"参考: https://www.cnblogs.com/pandabang/p/10441242.html\n音量大/小：上/下\n静音开/关：M\n回退/快进：ALT+左/右（步进10s），CTRL+左/右（步进1min）\n跳到指定时间：CTRL+T\n播放/暂停：空格\n停止播放：S（与暂停不同，按下停止后播放进度条回到视频最开始，且窗口不显示视频；而暂停时，窗口显示暂停时的视频）\n播放速度：{或- 减慢，最慢速度0.02倍正常速度；} 加速，最快速度31.25倍正常速度； = 正常速度\n全屏开/关：F\n纵横比切换：A（默认、16:9、4:3、1:1、16:10、2.21:1、2:35:1、2.39:1、5:4）\n窗口尺寸切换：Z（¼、½、原始尺寸、2倍原始尺寸）\n显示播放时间/总时长：T\n播放控件显示/不显示：CTRL+H\n","date":"2022-09-04T16:25:18+08:00","permalink":"https://changxiangyu.cn/p/vlc%E6%92%AD%E6%94%BE%E5%99%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","title":"VLC播放器快捷键"},{"content":"参考：https://blog.csdn.net/wxhcyy/article/details/107718794\n下载安装文件 1 2 # 链接从官方找 wget https://www.python.org/ftp/python/3.6.8/Python-3.6.8.tar.xz 解压 1 2 export d_path=\u0026#39;\u0026#39; tar xf Python-3.6.8.tar.xz -C $d_path 安装 1 2 3 4 cd $d_path ./configure --prefix=$d_path/python3.6.8 make all make install 测试 1 $d_path/python3.6.8/python -V ","date":"2022-08-26T16:27:18+08:00","permalink":"https://changxiangyu.cn/p/linux-%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85-python/","title":"linux 系统，使用源码安装 Python"},{"content":"File -\u0026gt; Settings -\u0026gt; Project: project_name -\u0026gt; Project Interpreter -\u0026gt; Add\u0026hellip; -\u0026gt; Virtualenv Environment -\u0026gt; (配置) -\u0026gt; OK\nsource project_path/venv/bin/activate\n命令行 Installation\nTo install virtualenv via pip run:\n1 $ pip3 install virtualenv Usage\nCreation of virtualenv:\n1 $ virtualenv -p python3 \u0026lt;desired-path\u0026gt; Activate the virtualenv:\n1 $ source \u0026lt;desired-path\u0026gt;/bin/activate Deactivate the virtualenv:\n1 $ deactivate ","date":"2022-08-26T15:04:18+08:00","permalink":"https://changxiangyu.cn/p/pycharm-%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/","title":"pycharm 项目配置虚拟环境"},{"content":"转载：https://juejin.cn/post/6844903602968854542\n设置记住密码（默认15分钟） 可以将你的密码缓存下来，只用输一次密码，以后都可以不用输入了。缺点就是密码都明文保存在 ~/.git-credential 文件中。\n1 git config --global credential.helper cache 如果想自己设置时间，可以使用以下命令：\n1 git config credential.helper \u0026#39;cache --timeout=3600\u0026#39; 这样就设置一个小时之后失效\n长期存储密码： 1 git config --global credential.helper store 增加远程地址的时候带上密码也是可以的。(推荐)\n1 http://yourname:password@git.oschina.net/name/project.git 补充：使用客户端也可以存储密码。\n如果你正在使用ssh而且想体验https带来的高速，那么你可以这样做： 切换到项目目录下 ：\n1 cd project/ 移除远程ssh方式的仓库地址\n1 git remote rm origin 复制代码增加https远程仓库地址\n1 git remote add origin http://yourname:password@git.oschina.net/name/project.git ","date":"2022-08-26T14:36:18+08:00","permalink":"https://changxiangyu.cn/p/git-http%E6%96%B9%E5%BC%8F%E5%85%8D%E5%AF%86%E6%8F%90%E4%BA%A4/","title":"git http方式免密提交"},{"content":"参考链接\nhttps://www.ruanyifeng.com/blog/2020/08/rsync.html How To Use Rsync to Sync Local and Remote Directories on a VPS, Justin Ellingwood Mirror Your Web Site With rsync, Falko Timme Examples on how to use Rsync, Egidio Docile How to create incremental backups using rsync on Linux, Egidio Docile 一、简介 rsync 是一个常用的 Linux 应用程序，用于文件同步。\n它可以在本地计算机与远程计算机之间，或者两个本地目录之间同步文件（但不支持两台远程计算机之间的同步）。它也可以当作文件复制工具，替代cp和mv命令。\n它名称里面的r指的是 remote，rsync 其实就是\u0026quot;远程同步\u0026quot;（remote sync）的意思。与其他文件传输工具（如 FTP 或 scp）不同，rsync 的最大特点是会检查发送方和接收方已有的文件，仅传输有变动的部分（默认规则是文件大小或修改时间有变动）。\n二、安装 1 2 3 4 5 # Ubuntu/Debian $ sudo apt-get install rsync # CentOS/Red Hat $ sudo yum install rsync 注意，传输的双方都必须安装 rsync。\n三、基本用法 3.1 -r 参数 本机使用 rsync 命令时，可以作为cp和mv命令的替代方法，将源目录同步到目标目录。\n1 $ rsync -r source destination 上面命令中，-r表示递归，即包含子目录。注意，-r是必须的，否则 rsync 运行不会成功。source目录表示源目录，destination表示目标目录。\n如果有多个文件或目录需要同步，可以写成下面这样。\n1 $ rsync -r source1 source2 destination 上面命令中，source1、source2都会被同步到destination目录。\n3.2 -a 参数 -a参数可以替代-r，除了可以递归同步以外，还可以同步元信息（比如修改时间、权限等）。由于 rsync 默认使用文件大小和修改时间决定文件是否需要更新，所以-a比-r更有用。下面的用法才是常见的写法。\n1 $ rsync -a source destination 目标目录destination如果不存在，rsync 会自动创建。执行上面的命令后，源目录source被完整地复制到了目标目录destination下面，即形成了destination/source的目录结构。\n如果只想同步源目录source里面的内容到目标目录destination，则需要在源目录后面加上斜杠。\n1 $ rsync -a source/ destination 上面命令执行后，source目录里面的内容，就都被复制到了destination目录里面，并不会在destination下面创建一个source子目录。\n3.3 -n 参数 如果不确定 rsync 执行后会产生什么结果，可以先用-n或\u0026ndash;dry-run参数模拟执行的结果。\n1 $ rsync -anv source/ destination 上面命令中，-n参数模拟命令执行的结果，并不真的执行命令。-v参数则是将结果输出到终端，这样就可以看到哪些内容会被同步。\n3.4 \u0026ndash;delete 参数 默认情况下，rsync 只确保源目录的所有内容（明确排除的文件除外）都复制到目标目录。它不会使两个目录保持相同，并且不会删除文件。如果要使得目标目录成为源目录的镜像副本，则必须使用\u0026ndash;delete参数，这将删除只存在于目标目录、不存在于源目录的文件。\n1 $ rsync -av --delete source/ destination 上面命令中，\u0026ndash;delete参数会使得destination成为source的一个镜像。\n四、排除文件 4.1 \u0026ndash;exclude 参数 有时，我们希望同步时排除某些文件或目录，这时可以用\u0026ndash;exclude参数指定排除模式。\n1 2 3 $ rsync -av --exclude=\u0026#39;*.txt\u0026#39; source/ destination # 或者 $ rsync -av --exclude \u0026#39;*.txt\u0026#39; source/ destination 上面命令排除了所有 TXT 文件。\n注意，rsync 会同步以\u0026quot;点\u0026quot;开头的隐藏文件，如果要排除隐藏文件，可以这样写\u0026ndash;exclude=\u0026quot;.*\u0026quot;。\n如果要排除某个目录里面的所有文件，但不希望排除目录本身，可以写成下面这样。\n1 $ rsync -av --exclude \u0026#39;dir1/*\u0026#39; source/ destination 多个排除模式，可以用多个\u0026ndash;exclude参数。\n1 $ rsync -av --exclude \u0026#39;file1.txt\u0026#39; --exclude \u0026#39;dir1/*\u0026#39; source/ destination 多个排除模式也可以利用 Bash 的大扩号的扩展功能，只用一个\u0026ndash;exclude参数。\n1 $ rsync -av --exclude={\u0026#39;file1.txt\u0026#39;,\u0026#39;dir1/*\u0026#39;} source/ destination 如果排除模式很多，可以将它们写入一个文件，每个模式一行，然后用\u0026ndash;exclude-from参数指定这个文件。\n1 $ rsync -av --exclude-from=\u0026#39;exclude-file.txt\u0026#39; source/ destination 4.2 \u0026ndash;include 参数 \u0026ndash;include参数用来指定必须同步的文件模式，往往与\u0026ndash;exclude结合使用。\n1 $ rsync -av --include=\u0026#34;*.txt\u0026#34; --exclude=\u0026#39;*\u0026#39; source/ destination 上面命令指定同步时，排除所有文件，但是会包括 TXT 文件。\n五、远程同步 5.1 SSH 协议 rsync 除了支持本地两个目录之间的同步，也支持远程同步。它可以将本地内容，同步到远程服务器。\n1 $ rsync -av source/ username@remote_host:destination 也可以将远程内容同步到本地。\n1 $ rsync -av username@remote_host:source/ destination rsync 默认使用 SSH 进行远程登录和数据传输。\n由于早期 rsync 不使用 SSH 协议，需要用-e参数指定协议，后来才改的。所以，下面-e ssh可以省略。\n1 $ rsync -av -e ssh source/ user@remote_host:/destination 但是，如果 ssh 命令有附加的参数，则必须使用-e参数指定所要执行的 SSH 命令。\n1 $ rsync -av -e \u0026#39;ssh -p 2234\u0026#39; source/ user@remote_host:/destination 上面命令中，-e参数指定 SSH 使用2234端口。\n5.2 rsync 协议 除了使用 SSH，如果另一台服务器安装并运行了 rsync 守护程序，则也可以用rsync://协议（默认端口873）进行传输。具体写法是服务器与目标目录之间使用双冒号分隔::。\n1 $ rsync -av source/ 192.168.122.32::module/destination 注意，上面地址中的module并不是实际路径名，而是 rsync 守护程序指定的一个资源名，由管理员分配。\n如果想知道 rsync 守护程序分配的所有 module 列表，可以执行下面命令。\n1 $ rsync rsync://192.168.122.32 rsync 协议除了使用双冒号，也可以直接用rsync://协议指定地址。\n1 $ rsync -av source/ rsync://192.168.122.32/module/destination 六、增量备份 rsync 的最大特点就是它可以完成增量备份，也就是默认只复制有变动的文件。\n除了源目录与目标目录直接比较，rsync 还支持使用基准目录，即将源目录与基准目录之间变动的部分，同步到目标目录。\n具体做法是，第一次同步是全量备份，所有文件在基准目录里面同步一份。以后每一次同步都是增量备份，只同步源目录与基准目录之间有变动的部分，将这部分保存在一个新的目标目录。这个新的目标目录之中，也是包含所有文件，但实际上，只有那些变动过的文件是存在于该目录，其他没有变动的文件都是指向基准目录文件的硬链接。\n\u0026ndash;link-dest参数用来指定同步时的基准目录。\n1 $ rsync -a --delete --link-dest /compare/path /source/path /target/path 上面命令中，\u0026ndash;link-dest参数指定基准目录/compare/path，然后源目录/source/path跟基准目录进行比较，找出变动的文件，将它们拷贝到目标目录/target/path。那些没变动的文件则会生成硬链接。这个命令的第一次备份时是全量备份，后面就都是增量备份了。\n下面是一个脚本示例，备份用户的主目录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #!/bin/bash # A script to perform incremental backups using rsync set -o errexit set -o nounset set -o pipefail readonly SOURCE_DIR=\u0026#34;${HOME}\u0026#34; readonly BACKUP_DIR=\u0026#34;/mnt/data/backups\u0026#34; readonly DATETIME=\u0026#34;$(date \u0026#39;+%Y-%m-%d_%H:%M:%S\u0026#39;)\u0026#34; readonly BACKUP_PATH=\u0026#34;${BACKUP_DIR}/${DATETIME}\u0026#34; readonly LATEST_LINK=\u0026#34;${BACKUP_DIR}/latest\u0026#34; mkdir -p \u0026#34;${BACKUP_DIR}\u0026#34; rsync -av --delete \\ \u0026#34;${SOURCE_DIR}/\u0026#34; \\ --link-dest \u0026#34;${LATEST_LINK}\u0026#34; \\ --exclude=\u0026#34;.cache\u0026#34; \\ \u0026#34;${BACKUP_PATH}\u0026#34; rm -rf \u0026#34;${LATEST_LINK}\u0026#34; ln -s \u0026#34;${BACKUP_PATH}\u0026#34; \u0026#34;${LATEST_LINK}\u0026#34; 上面脚本中，每一次同步都会生成一个新目录${BACKUP_DIR}/${DATETIME}，并将软链接${BACKUP_DIR}/latest指向这个目录。下一次备份时，就将${BACKUP_DIR}/latest作为基准目录，生成新的备份目录。最后，再将软链接${BACKUP_DIR}/latest指向新的备份目录。\n七、配置项 -a、\u0026ndash;archive参数表示存档模式，保存所有的元数据，比如修改时间（modification time）、权限、所有者等，并且软链接也会同步过去。\n\u0026ndash;append参数指定文件接着上次中断的地方，继续传输。\n\u0026ndash;append-verify参数跟\u0026ndash;append参数类似，但会对传输完成后的文件进行一次校验。如果校验失败，将重新发送整个文件。\n-b、\u0026ndash;backup参数指定在删除或更新目标目录已经存在的文件时，将该文件更名后进行备份，默认行为是删除。更名规则是添加由\u0026ndash;suffix参数指定的文件后缀名，默认是~。\n\u0026ndash;backup-dir参数指定文件备份时存放的目录，比如\u0026ndash;backup-dir=/path/to/backups。\n\u0026ndash;bwlimit参数指定带宽限制，默认单位是 KB/s，比如\u0026ndash;bwlimit=100。\n-c、\u0026ndash;checksum参数改变rsync的校验方式。默认情况下，rsync 只检查文件的大小和最后修改日期是否发生变化，如果发生变化，就重新传输；使用这个参数以后，则通过判断文件内容的校验和，决定是否重新传输。\n\u0026ndash;delete参数删除只存在于目标目录、不存在于源目标的文件，即保证目标目录是源目标的镜像。\n-e参数指定使用 SSH 协议传输数据。\n\u0026ndash;exclude参数指定排除不进行同步的文件，比如\u0026ndash;exclude=\u0026quot;*.iso\u0026quot;。\n\u0026ndash;exclude-from参数指定一个本地文件，里面是需要排除的文件模式，每个模式一行。\n\u0026ndash;existing、\u0026ndash;ignore-non-existing参数表示不同步目标目录中不存在的文件和目录。\n-h参数表示以人类可读的格式输出。\n-h、\u0026ndash;help参数返回帮助信息。\n-i参数表示输出源目录与目标目录之间文件差异的详细情况。\n\u0026ndash;ignore-existing参数表示只要该文件在目标目录中已经存在，就跳过去，不再同步这些文件。\n\u0026ndash;include参数指定同步时要包括的文件，一般与\u0026ndash;exclude结合使用。\n\u0026ndash;link-dest参数指定增量备份的基准目录。\n-m参数指定不同步空目录。\n\u0026ndash;max-size参数设置传输的最大文件的大小限制，比如不超过200KB（\u0026ndash;max-size=\u0026lsquo;200k\u0026rsquo;）。\n\u0026ndash;min-size参数设置传输的最小文件的大小限制，比如不小于10KB（\u0026ndash;min-size=10k）。\n-n参数或\u0026ndash;dry-run参数模拟将要执行的操作，而并不真的执行。配合-v参数使用，可以看到哪些内容会被同步过去。\n-P参数是\u0026ndash;progress和\u0026ndash;partial这两个参数的结合。\n\u0026ndash;partial参数允许恢复中断的传输。不使用该参数时，rsync会删除传输到一半被打断的文件；使用该参数后，传输到一半的文件也会同步到目标目录，下次同步时再恢复中断的传输。一般需要与\u0026ndash;append或\u0026ndash;append-verify配合使用。\n\u0026ndash;partial-dir参数指定将传输到一半的文件保存到一个临时目录，比如\u0026ndash;partial-dir=.rsync-partial。一般需要与\u0026ndash;append或\u0026ndash;append-verify配合使用。\n\u0026ndash;progress参数表示显示进展。\n-r参数表示递归，即包含子目录。\n\u0026ndash;remove-source-files参数表示传输成功后，删除发送方的文件。\n\u0026ndash;size-only参数表示只同步大小有变化的文件，不考虑文件修改时间的差异。\n\u0026ndash;suffix参数指定文件名备份时，对文件名添加的后缀，默认是~。\n-u、\u0026ndash;update参数表示同步时跳过目标目录中修改时间更新的文件，即不同步这些有更新的时间戳的文件。\n-v参数表示输出细节。-vv表示输出更详细的信息，-vvv表示输出最详细的信息。\n\u0026ndash;version参数返回 rsync 的版本。\n-z参数指定同步时压缩数据。\n","date":"2022-08-19T17:03:18+08:00","permalink":"https://changxiangyu.cn/p/%E8%BF%9C%E7%A8%8B%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6-rsync/","title":"远程传输文件-rsync"},{"content":" 1 find . -type f -name \u0026#34;*.yaml\u0026#34; | xargs sed -i \u0026#34;s#host_path#$host_path#g\u0026#34; ","date":"2022-08-17T17:38:18+08:00","permalink":"https://changxiangyu.cn/p/%E6%9B%BF%E6%8D%A2%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%9A%84%E7%89%B9%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"替换文件夹中所有文件内容的特定字符串"},{"content":"参考: https://blog.csdn.net/laobai1015/article/details/98628860\n需求 把 /etc/rancher/k3s/k3s.yaml 文件的内容，每行前面加 4 个空格，追加到 ai-service-platform/yamls/config/kube-config.yaml 文件中； 把 ai-service-platform/yamls/config/kube-config.yaml 文件中的 127.0.0.1 替换成 $master_host_ip。 脚本：\n1 2 3 4 function fix_kube_config(){ sudo awk \u0026#39;{print \u0026#34; \u0026#34; $0 \u0026gt;\u0026gt; \u0026#34;ai-service-platform/yamls/config/kube-config.yaml\u0026#34;}\u0026#39; /etc/rancher/k3s/k3s.yaml sed -i \u0026#34;s/127.0.0.1/$master_host_ip/g\u0026#34; ai-service-platform/yamls/config/kube-config.yaml } 扩展 在前面、后面、指定列添加相同字符\n给一个文件中的每一行开头插入字符的方法：awk \u0026lsquo;{print \u0026ldquo;需要添加的字符\u0026rdquo; $0}\u0026rsquo; fileName 给一个文件中的每一行结尾插入字符的方法：awk \u0026lsquo;{print $0 \u0026ldquo;需要添加的字符\u0026rdquo;}\u0026rsquo; fileName 给一个文件中的每一行的指定列插入字符的方法：awk \u0026lsquo;$0=$0 X\u0026quot;\u0026rsquo; fileName 删除某一个列\n删除文件中的第一列：awk \u0026lsquo;{$1=\u0026quot;\u0026quot;;print $0}\u0026rsquo; fileName 或者另一种方法 sed -e \u0026rsquo;s/[^ ]* //\u0026rsquo; text 删除指定列：awk \u0026lsquo;{$Num=\u0026quot;\u0026quot;;print $0}\u0026rsquo; fileName 把Num换成要删除的列数即可\n练习 给文件中的每一行开头添加drop tables\n1 awk \u0026#39;{print \u0026#34;drop table \u0026#34;$0}\u0026#39; aa.txt \u0026gt; bb.txt 给文件中的每一行结尾添加分号\n1 awk \u0026#39;{print $0\u0026#34;;\u0026#34;}\u0026#39; bb.txt \u0026gt; cc.txt ","date":"2022-08-17T10:03:18+08:00","permalink":"https://changxiangyu.cn/p/linux-%E4%B8%8B%E4%BD%BF%E7%94%A8-awk-%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/","title":"Linux 下使用 awk 操作文件内容"},{"content":"参考: https://developer.aliyun.com/article/53579\nmycode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import os import math if __name__ == \u0026#39;__main__\u0026#39;: vfs = os.statvfs(\u0026#34;/home/manager\u0026#34;) g = 1024 * 1024 * 1024 # 总容量 k_blocks = vfs.f_bsize * vfs.f_blocks / g # Used,使用量，总容量减去空闲容量 used = vfs.f_bsize * (vfs.f_blocks - vfs.f_bfree) / g # Available，有效容量 available = vfs.f_bsize * vfs.f_bavail / g # use%,使用量，%,round(浮点数，精确到小数点后的位数） use = round(used / (used + available) * 100, 2) print({ \u0026#34;容量\u0026#34;: k_blocks, \u0026#34;已用\u0026#34;: used, \u0026#34;可用\u0026#34;: available, \u0026#34;已用%\u0026#34;: use, }) print({ \u0026#34;容量\u0026#34;: f\u0026#39;{math.ceil(k_blocks)}G\u0026#39;, \u0026#34;已用\u0026#34;: f\u0026#39;{math.ceil(used)}G\u0026#39;, \u0026#34;可用\u0026#34;: f\u0026#39;{math.ceil(available)}G\u0026#39;, \u0026#34;已用%\u0026#34;: f\u0026#39;{math.ceil(use)}%\u0026#39;, }) 运行测试\n1 2 3 $ df -h /home/manager 文件系统 容量 已用 可用 已用% 挂载点 /dev/nvme0n1p2 457G 325G 110G 75% / 1 2 3 python test.py {\u0026#39;容量\u0026#39;: 456.8854446411133, \u0026#39;已用\u0026#39;: 324.40053939819336, \u0026#39;可用\u0026#39;: 109.20629501342773, \u0026#39;已用%\u0026#39;: 74.81} {\u0026#39;容量\u0026#39;: \u0026#39;457G\u0026#39;, \u0026#39;已用\u0026#39;: \u0026#39;325G\u0026#39;, \u0026#39;可用\u0026#39;: \u0026#39;110G\u0026#39;, \u0026#39;已用%\u0026#39;: \u0026#39;75%\u0026#39;} ","date":"2022-08-15T17:03:18+08:00","permalink":"https://changxiangyu.cn/p/python-%E5%AE%9E%E7%8E%B0-linux-%E7%9A%84-df-h-%E5%91%BD%E4%BB%A4/","title":"Python 实现 Linux 的 'df -h' 命令"},{"content":"编辑文件：\n1 sudo gedit /etc/systemd/logind.conf 1 2 3 4 #HandlePowerKey按下电源键后的行为，默认power off #HandleSleepKey 按下挂起键后的行为，默认suspend #HandleHibernateKey按下休眠键后的行为，默认hibernate #HandleLidSwitch合上笔记本盖后的行为，一般为默认suspend（改为ignore；即合盖不休眠）在原文件中，还要去掉前面的# 1 2 3 4 然后将其中的： #HandleLidSwitch=suspend 复制一行到下面，去掉“#”号： HandleLidSwitch=ignore 最后重启服务\n1 service systemd-logind restart ","date":"2022-08-13T15:33:18+08:00","permalink":"https://changxiangyu.cn/p/ubuntu-%E8%AE%BE%E7%BD%AE%E5%90%88%E4%B8%8A%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%9B%96%E5%AD%90%E4%B8%8D%E4%BC%91%E7%9C%A0%E7%9A%84%E6%96%B9%E6%B3%95/","title":"Ubuntu 设置合上笔记本盖子不休眠的方法"},{"content":"pip freeze \u0026gt; test.txt\npip uninstall -r test.txt -y\npip install -r requirements.txt\n","date":"2022-08-08T18:13:18+08:00","permalink":"https://changxiangyu.cn/p/python-%E6%B8%85%E7%90%86%E5%8C%85/","title":"python 清理包"},{"content":"准备检查：内存条，硬盘，主板电池\n","date":"2022-08-08T18:13:18+08:00","permalink":"https://changxiangyu.cn/p/%E7%94%B5%E8%84%91%E5%BC%80%E4%B8%8D%E4%BA%86%E6%9C%BA/","title":"电脑开不了机"},{"content":" 记录我们最珍贵的时刻，每一张都是爱的见证。\n","date":"2022-08-07T15:47:18+08:00","image":"https://changxiangyu.cn/images/small-15x15-album/fm-15.jpg","permalink":"https://changxiangyu.cn/p/%E5%A9%9A%E7%BA%B1%E7%85%A7-15x15-%E7%9B%B8%E5%86%8C%E7%B2%BE%E9%80%89/","title":"婚纱照 15x15 相册精选"},{"content":" 记录我们最珍贵的时刻，每一张都是爱的见证。\n","date":"2022-08-07T15:33:18+08:00","image":"https://changxiangyu.cn/images/small-12x12-album/fm-15.jpg","permalink":"https://changxiangyu.cn/p/%E5%A9%9A%E7%BA%B1%E7%85%A7-12x12-%E7%9B%B8%E5%86%8C/","title":"婚纱照 12x12 相册"},{"content":"初见三摆台 至美三件套艺术组合 10X8英寸时尚绢丝相架一幅 10X8英寸精美思慕相架一幅 30X20英寸时尚绢丝挂画一幅 48X24至美相框一幅 6X8英寸时尚蓝色恋人相架一幅 8X12英寸精美米娜相架一幅 8X8英寸安琪相架一幅 ","date":"2022-08-07T15:33:18+08:00","image":"https://changxiangyu.cn/images/small-photos-decorations/y_259.jpg","permalink":"https://changxiangyu.cn/p/%E5%A9%9A%E7%BA%B1%E7%85%A7%E6%91%86%E4%BB%B6/","title":"婚纱照摆件"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 # 准备工作：安装 imagemagick sudo apt-get install imagemagick #大图所在的目录 cd /path/to/big/images #创建小图对应的目录结构 find . -type d -print -exec mkdir \u0026#39;../small/{}\u0026#39; -p \\; #批量转换! 等比例缩小到320x320之内 320x: 只设置宽度 find . -type f -name \u0026#39;*.jpg\u0026#39; -print -exec \\ convert \u0026#39;{}\u0026#39; -resize 320x320 \u0026#39;../small/{}\u0026#39; \\; ","date":"2022-08-07T02:33:18+08:00","permalink":"https://changxiangyu.cn/p/ubuntu%E4%B8%8B%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%90%E7%BC%A9%E7%95%A5%E5%9B%BE/","title":"Ubuntu下在命令行批量生成缩略图"},{"content":"Step 1: Install Hugo 1 2 3 # Ubuntu 系统 sudo apt update sudo apt install hugo 验证您的新安装:\n1 hugo version 1 2 Output hugo v0.101.0-9f74196ce611cdf6d355bfb99fd8eba5c68ef7f8+extended linux/amd64 BuildDate=2022-06-28T10:02:18Z VendorInfo=snap Step 2: Create a New Site 1 hugo new site quickstart 这个命令会创建一个名为 quickstart 的目录，这就是博客的根目录。目录结构如下：\n1 2 3 4 5 6 7 8 ├── archetypes │ └── default.md ├── config.toml # 博客站点的配置文件 ├── content # 博客文章所在目录 ├── data ├── layouts # 网站布局 ├── static # 一些静态内容 └── themes # 博客主题 Step 3: Add a Theme 首先，从 GitHub 下载主题并将其添加到站点的主题目录中：\n1 2 3 cd quickstart git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke 然后，将主题添加到站点配置中：\n1 echo theme = \\\u0026#34;ananke\\\u0026#34; \u0026gt;\u0026gt; config.toml Step 4: Add Some Content 1 hugo new posts/my-first-post.md 如果需要，可以编辑新创建的内容文件，它将以如下内容开头：\n1 2 3 4 5 --- title: \u0026#34;My First Post\u0026#34; date: 2019-03-26T08:47:11+01:00 draft: true --- Step 5: Start the Hugo server 现在，启动启用草稿的 Hugo 服务器：\n1 2 3 4 5 6 hugo server -D # 可以在其它机器访问 hugo server --bind=\u0026#34;0.0.0.0\u0026#34; -D # 可以在其它机器访问, -p 修改端口 hugo server --bind=\u0026#34;0.0.0.0\u0026#34; -p 80 -D 在 http://114.132.247.115:1313/ 导航到您的新站点。\n第 6 步：自定义主题 在文本编辑器中打开 config.toml：\n1 2 3 4 baseURL = \u0026#34;https://example.org/\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;My New Hugo Site\u0026#34; theme = \u0026#34;ananke\u0026#34; 第 7 步：构建静态页面 1 hugo -D ","date":"2022-08-01T19:52:18+08:00","permalink":"https://changxiangyu.cn/p/quick-start/","title":"Quick Start"},{"content":"准备要部署的内容 在github 上创建一个仓库: chenjinxin.github.io\n要向仓库中存放的内容，使用 hugo 命令生成的。在当前目录下，运行 hugo 命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ➜ quickstart git:(master) ✗ pwd /home/cjx/quickstart ➜ quickstart git:(master) hugo Start building sites … hugo v0.101.0-9f74196ce611cdf6d355bfb99fd8eba5c68ef7f8+extended linux/amd64 BuildDate=2022-06-28T10:02:18Z VendorInfo=snap | EN -------------------+----- Pages | 28 Paginator pages | 0 Non-page files | 0 Static files | 0 Processed images | 0 Aliases | 12 Sitemaps | 1 Cleaned | 0 Total in 33 ms 执行成功后，会生成一个public 目录，这个目录中的内容，就是我们博客系统的所有内容，我们需要将这些内容存放在Git 仓库中。\n部署到 GitHub 按照如下步骤将博客内容上传到Git 仓库，在public 目录下，依次执行下面的命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 初始化仓库 git init # 将所有内容添加到git git add . # 提交到git 本地 git commit -m \u0026#34;我的博客第一次提交\u0026#34; # 关联到远程git，注意这里需要写你自己的git 地址 git remote add origin git@github.com:chenjinxin1124/chenjinxin.github.io.git # 推送到远程git git push --set-upstream origin master ","date":"2022-08-01T00:00:00Z","permalink":"https://changxiangyu.cn/p/%E5%B0%86%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%9C%A8github%E4%B8%8A/","title":"将博客部署在GitHub上"},{"content":"初始化本地仓库 1 git init 添加代码 1 git add . 提交代码 1 git commit -m\u0026#39;first commit\u0026#39; 添加远程仓库地址 1 git remote add origin git@github.com:jinyumantangcjx/hugo.git 把本地仓库的变化连接到远程仓库主分支 1 git push --set-upstream origin master ","date":"2022-08-01T00:00:00Z","permalink":"https://changxiangyu.cn/p/%E6%8E%A8%E9%80%81%E5%88%B0github/","title":"推送到GitHub"},{"content":"下载博客主题 创建好博客项目后，接下来是下载hugo博客的主题，这里有很多主题，我们可以任意挑选，比如我们选择了bootstrap4-blog 主题。\n然后在 Blog 目录下使用git 命令来下载主题：\n1 git clone https://github.com/alanorth/hugo-theme-bootstrap4-blog.git themes/hugo-theme-bootstrap4-blog 下载下来的主题会放在themes 目录中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 └── hugo-theme-bootstrap4-blog ├── CHANGELOG.md ├── LICENSE.txt ├── README.md ├── archetypes ├── assets ├── exampleSite # 本主题示例内容 | ├── content # 示例博客文章 │ |-- static │ |-- config.toml # 本主题配置 ├── i18n ├── images ├── layouts ├── package-lock.json ├── package.json ├── screenshot.png ├── source ├── theme.toml └── webpack.config.js 使用主题 1 2 3 vim config.toml theme = \u0026#34;hugo-theme-bootstrap4-blog\u0026#34; ","date":"2022-08-01T00:00:00Z","permalink":"https://changxiangyu.cn/p/%E4%BF%AE%E6%94%B9%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/","title":"修改博客主题"}]